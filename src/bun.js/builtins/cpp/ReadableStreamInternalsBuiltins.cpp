/*
 * Copyright (c) 2015 Igalia
 * Copyright (c) 2015 Igalia S.L.
 * Copyright (c) 2015 Igalia.
 * Copyright (c) 2015, 2016 Canon Inc. All rights reserved.
 * Copyright (c) 2015, 2016, 2017 Canon Inc.
 * Copyright (c) 2016, 2020 Apple Inc. All rights reserved.
 * Copyright (c) 2022 Codeblog Corp. All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 * 
 */

// DO NOT EDIT THIS FILE. It is automatically generated from JavaScript files for
// builtins by the script: Source/JavaScriptCore/Scripts/generate-js-builtins.py

#include "config.h"
#include "ReadableStreamInternalsBuiltins.h"

#include "WebCoreJSClientData.h"
#include <JavaScriptCore/HeapInlines.h>
#include <JavaScriptCore/IdentifierInlines.h>
#include <JavaScriptCore/Intrinsic.h>
#include <JavaScriptCore/JSCJSValueInlines.h>
#include <JavaScriptCore/JSCellInlines.h>
#include <JavaScriptCore/StructureInlines.h>
#include <JavaScriptCore/VM.h>

namespace WebCore {

const JSC::ConstructAbility s_readableStreamInternalsReadableStreamReaderGenericInitializeCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsReadableStreamReaderGenericInitializeCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsReadableStreamReaderGenericInitializeCodeLength = 756;
static const JSC::Intrinsic s_readableStreamInternalsReadableStreamReaderGenericInitializeCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsReadableStreamReaderGenericInitializeCode =
    "(function (reader, stream)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    @putByIdDirectPrivate(reader, \"ownerReadableStream\", stream);\n" \
    "    @putByIdDirectPrivate(stream, \"reader\", reader);\n" \
    "    if (@getByIdDirectPrivate(stream, \"state\") === @streamReadable)\n" \
    "        @putByIdDirectPrivate(reader, \"closedPromiseCapability\", @newPromiseCapability(@Promise));\n" \
    "    else if (@getByIdDirectPrivate(stream, \"state\") === @streamClosed)\n" \
    "        @putByIdDirectPrivate(reader, \"closedPromiseCapability\", { @promise: @Promise.@resolve() });\n" \
    "    else {\n" \
    "        @assert(@getByIdDirectPrivate(stream, \"state\") === @streamErrored);\n" \
    "        @putByIdDirectPrivate(reader, \"closedPromiseCapability\", { @promise: @newHandledRejectedPromise(@getByIdDirectPrivate(stream, \"storedError\")) });\n" \
    "    }\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsPrivateInitializeReadableStreamDefaultControllerCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsPrivateInitializeReadableStreamDefaultControllerCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsPrivateInitializeReadableStreamDefaultControllerCodeLength = 899;
static const JSC::Intrinsic s_readableStreamInternalsPrivateInitializeReadableStreamDefaultControllerCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsPrivateInitializeReadableStreamDefaultControllerCode =
    "(function (stream, underlyingSource, size, highWaterMark)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    \n" \
    "        if (!@isReadableStream(stream))\n" \
    "        @throwTypeError(\"ReadableStreamDefaultController needs a ReadableStream\");\n" \
    "\n" \
    "    //\n" \
    "    if (@getByIdDirectPrivate(stream, \"readableStreamController\") !== null)\n" \
    "        @throwTypeError(\"ReadableStream already has a controller\");\n" \
    "\n" \
    "        \n" \
    "\n" \
    "    @putByIdDirectPrivate(this, \"controlledReadableStream\", stream);\n" \
    "    @putByIdDirectPrivate(this, \"underlyingSource\", underlyingSource);\n" \
    "    @putByIdDirectPrivate(this, \"queue\", @newQueue());\n" \
    "    @putByIdDirectPrivate(this, \"started\", -1);\n" \
    "    @putByIdDirectPrivate(this, \"closeRequested\", false);\n" \
    "    @putByIdDirectPrivate(this, \"pullAgain\", false);\n" \
    "    @putByIdDirectPrivate(this, \"pulling\", false);\n" \
    "    @putByIdDirectPrivate(this, \"strategy\", @validateAndNormalizeQueuingStrategy(size, highWaterMark));\n" \
    "\n" \
    "    return this;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsReadableStreamDefaultControllerErrorCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsReadableStreamDefaultControllerErrorCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsReadableStreamDefaultControllerErrorCodeLength = 327;
static const JSC::Intrinsic s_readableStreamInternalsReadableStreamDefaultControllerErrorCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsReadableStreamDefaultControllerErrorCode =
    "(function (controller, error)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    const stream = @getByIdDirectPrivate(controller, \"controlledReadableStream\");\n" \
    "    if (@getByIdDirectPrivate(stream, \"state\") !== @streamReadable)\n" \
    "        return;\n" \
    "    @putByIdDirectPrivate(controller, \"queue\", @newQueue());\n" \
    "    \n" \
    "    @readableStreamError(stream, error);\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsReadableStreamPipeToCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsReadableStreamPipeToCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsReadableStreamPipeToCodeLength = 778;
static const JSC::Intrinsic s_readableStreamInternalsReadableStreamPipeToCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsReadableStreamPipeToCode =
    "(function (stream, sink)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    @assert(@isReadableStream(stream));\n" \
    "\n" \
    "    const reader = new @ReadableStreamDefaultReader(stream);\n" \
    "\n" \
    "    @getByIdDirectPrivate(reader, \"closedPromiseCapability\").@promise.@then(() => { }, (e) => { sink.error(e); });\n" \
    "\n" \
    "    function doPipe() {\n" \
    "        @readableStreamDefaultReaderRead(reader).@then(function(result) {\n" \
    "            if (result.done) {\n" \
    "                sink.close();\n" \
    "                return;\n" \
    "            }\n" \
    "            try {\n" \
    "                sink.enqueue(result.value);\n" \
    "            } catch (e) {\n" \
    "                sink.error(\"ReadableStream chunk enqueueing in the sink failed\");\n" \
    "                return;\n" \
    "            }\n" \
    "            doPipe();\n" \
    "        }, function(e) {\n" \
    "            sink.error(e);\n" \
    "        });\n" \
    "    }\n" \
    "    doPipe();\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsAcquireReadableStreamDefaultReaderCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsAcquireReadableStreamDefaultReaderCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsAcquireReadableStreamDefaultReaderCodeLength = 204;
static const JSC::Intrinsic s_readableStreamInternalsAcquireReadableStreamDefaultReaderCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsAcquireReadableStreamDefaultReaderCode =
    "(function (stream)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    var start = @getByIdDirectPrivate(stream, \"start\");\n" \
    "    if (start) {\n" \
    "        start.@call(stream);\n" \
    "    }\n" \
    "\n" \
    "    return new @ReadableStreamDefaultReader(stream);\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsSetupReadableStreamDefaultControllerCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsSetupReadableStreamDefaultControllerCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsSetupReadableStreamDefaultControllerCodeLength = 931;
static const JSC::Intrinsic s_readableStreamInternalsSetupReadableStreamDefaultControllerCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsSetupReadableStreamDefaultControllerCode =
    "(function (stream, underlyingSource, size, highWaterMark, startMethod, pullMethod, cancelMethod)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    \n" \
    "    const controller = new @ReadableStreamDefaultController(stream, underlyingSource, size, highWaterMark, @isReadableStream);\n" \
    "   \n" \
    "    const pullAlgorithm = () => @promiseInvokeOrNoopMethod(underlyingSource, pullMethod, [controller]);\n" \
    "    const cancelAlgorithm = (reason) => @promiseInvokeOrNoopMethod(underlyingSource, cancelMethod, [reason]);\n" \
    "    \n" \
    "    @putByIdDirectPrivate(controller, \"pullAlgorithm\", pullAlgorithm);\n" \
    "    @putByIdDirectPrivate(controller, \"cancelAlgorithm\", cancelAlgorithm);\n" \
    "    @putByIdDirectPrivate(controller, \"pull\", @readableStreamDefaultControllerPull);\n" \
    "    @putByIdDirectPrivate(controller, \"cancel\", @readableStreamDefaultControllerCancel);\n" \
    "    @putByIdDirectPrivate(stream, \"readableStreamController\", controller);\n" \
    "\n" \
    "    @readableStreamDefaultControllerStart(controller);\n" \
    "    \n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsCreateReadableStreamControllerCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsCreateReadableStreamControllerCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsCreateReadableStreamControllerCodeLength = 1196;
static const JSC::Intrinsic s_readableStreamInternalsCreateReadableStreamControllerCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsCreateReadableStreamControllerCode =
    "(function (stream, underlyingSource, strategy) {\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    const type = underlyingSource.type;\n" \
    "    const typeString = @toString(type);\n" \
    "\n" \
    "    if (typeString === \"bytes\") {\n" \
    "        //\n" \
    "        //\n" \
    "\n" \
    "        if (strategy.highWaterMark === @undefined)\n" \
    "            strategy.highWaterMark = 0;\n" \
    "        if (strategy.size !== @undefined)\n" \
    "            @throwRangeError(\"Strategy for a ReadableByteStreamController cannot have a size\");\n" \
    "\n" \
    "        @putByIdDirectPrivate(stream, \"readableStreamController\", new @ReadableByteStreamController(stream, underlyingSource, strategy.highWaterMark, @isReadableStream));\n" \
    "     } else if (typeString === \"direct\") {\n" \
    "        var highWaterMark = strategy?.highWaterMark;\n" \
    "        @initializeArrayBufferStream.@call(stream, underlyingSource, highWaterMark);  \n" \
    "     } else if (type === @undefined) {\n" \
    "        if (strategy.highWaterMark === @undefined)\n" \
    "            strategy.highWaterMark = 1;\n" \
    "            \n" \
    "        @setupReadableStreamDefaultController(stream, underlyingSource, strategy.size, strategy.highWaterMark, underlyingSource.start, underlyingSource.pull, underlyingSource.cancel);\n" \
    "    } else\n" \
    "        @throwRangeError(\"Invalid type for underlying source\");\n" \
    "\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsReadableStreamDefaultControllerStartCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsReadableStreamDefaultControllerStartCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsReadableStreamDefaultControllerStartCodeLength = 765;
static const JSC::Intrinsic s_readableStreamInternalsReadableStreamDefaultControllerStartCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsReadableStreamDefaultControllerStartCode =
    "(function (controller) {\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    \n" \
    "\n" \
    "    if (@getByIdDirectPrivate(controller, \"started\") !== -1)\n" \
    "        return;\n" \
    "\n" \
    "    const underlyingSource = @getByIdDirectPrivate(controller, \"underlyingSource\");\n" \
    "    const startMethod = underlyingSource.start;\n" \
    "    @putByIdDirectPrivate(controller, \"started\", 0);\n" \
    "\n" \
    "    @promiseInvokeOrNoopMethodNoCatch(underlyingSource, startMethod, [controller]).@then(() => {\n" \
    "        @putByIdDirectPrivate(controller, \"started\", 1);\n" \
    "        @assert(!@getByIdDirectPrivate(controller, \"pulling\"));\n" \
    "        @assert(!@getByIdDirectPrivate(controller, \"pullAgain\"));\n" \
    "        @readableStreamDefaultControllerCallPullIfNeeded(controller);\n" \
    "    }, (error) => {\n" \
    "        @readableStreamDefaultControllerError(controller, error);\n" \
    "    });\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsReadableStreamPipeToWritableStreamCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsReadableStreamPipeToWritableStreamCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsReadableStreamPipeToWritableStreamCodeLength = 3232;
static const JSC::Intrinsic s_readableStreamInternalsReadableStreamPipeToWritableStreamCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsReadableStreamPipeToWritableStreamCode =
    "(function (source, destination, preventClose, preventAbort, preventCancel, signal)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    @assert(@isReadableStream(source));\n" \
    "    @assert(@isWritableStream(destination));\n" \
    "    @assert(!@isReadableStreamLocked(source));\n" \
    "    @assert(!@isWritableStreamLocked(destination));\n" \
    "    @assert(signal === @undefined || @isAbortSignal(signal));\n" \
    "\n" \
    "    if (@getByIdDirectPrivate(source, \"underlyingByteSource\") !== @undefined)\n" \
    "        return @Promise.@reject(\"Piping to a readable bytestream is not supported\");\n" \
    "\n" \
    "    let pipeState = { source : source, destination : destination, preventAbort : preventAbort, preventCancel : preventCancel, preventClose : preventClose, signal : signal };\n" \
    "\n" \
    "    pipeState.reader = @acquireReadableStreamDefaultReader(source);\n" \
    "    pipeState.writer = @acquireWritableStreamDefaultWriter(destination);\n" \
    "\n" \
    "    @putByIdDirectPrivate(source, \"disturbed\", true);\n" \
    "\n" \
    "    pipeState.finalized = false;\n" \
    "    pipeState.shuttingDown = false;\n" \
    "    pipeState.promiseCapability = @newPromiseCapability(@Promise);\n" \
    "    pipeState.pendingReadPromiseCapability = @newPromiseCapability(@Promise);\n" \
    "    pipeState.pendingReadPromiseCapability.@resolve.@call();\n" \
    "    pipeState.pendingWritePromise = @Promise.@resolve();\n" \
    "\n" \
    "    if (signal !== @undefined) {\n" \
    "        const algorithm = () => {\n" \
    "            if (pipeState.finalized)\n" \
    "                return;\n" \
    "\n" \
    "            const error = @makeDOMException(\"AbortError\", \"abort pipeTo from signal\");\n" \
    "\n" \
    "            @pipeToShutdownWithAction(pipeState, () => {\n" \
    "                const shouldAbortDestination = !pipeState.preventAbort && @getByIdDirectPrivate(pipeState.destination, \"state\") === \"writable\";\n" \
    "                const promiseDestination = shouldAbortDestination ? @writableStreamAbort(pipeState.destination, error) : @Promise.@resolve();\n" \
    "\n" \
    "                const shouldAbortSource = !pipeState.preventCancel && @getByIdDirectPrivate(pipeState.source, \"state\") === @streamReadable;\n" \
    "                const promiseSource = shouldAbortSource ? @readableStreamCancel(pipeState.source, error) : @Promise.@resolve();\n" \
    "\n" \
    "                let promiseCapability = @newPromiseCapability(@Promise);\n" \
    "                let shouldWait = true;\n" \
    "                let handleResolvedPromise = () => {\n" \
    "                    if (shouldWait) {\n" \
    "                        shouldWait = false;\n" \
    "                        return;\n" \
    "                    }\n" \
    "                    promiseCapability.@resolve.@call();\n" \
    "                }\n" \
    "                let handleRejectedPromise = (e) => {\n" \
    "                    promiseCapability.@reject.@call(@undefined, e);\n" \
    "                }\n" \
    "                promiseDestination.@then(handleResolvedPromise, handleRejectedPromise);\n" \
    "                promiseSource.@then(handleResolvedPromise, handleRejectedPromise);\n" \
    "                return promiseCapability.@promise;\n" \
    "            }, error);\n" \
    "        };\n" \
    "        if (@whenSignalAborted(signal, algorithm))\n" \
    "            return pipeState.promiseCapability.@promise;\n" \
    "    }\n" \
    "\n" \
    "    @pipeToErrorsMustBePropagatedForward(pipeState);\n" \
    "    @pipeToErrorsMustBePropagatedBackward(pipeState);\n" \
    "    @pipeToClosingMustBePropagatedForward(pipeState);\n" \
    "    @pipeToClosingMustBePropagatedBackward(pipeState);\n" \
    "\n" \
    "    @pipeToLoop(pipeState);\n" \
    "\n" \
    "    return pipeState.promiseCapability.@promise;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsPipeToLoopCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsPipeToLoopCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsPipeToLoopCodeLength = 212;
static const JSC::Intrinsic s_readableStreamInternalsPipeToLoopCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsPipeToLoopCode =
    "(function (pipeState)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    if (pipeState.shuttingDown)\n" \
    "        return;\n" \
    "\n" \
    "    @pipeToDoReadWrite(pipeState).@then((result) => {\n" \
    "        if (result)\n" \
    "            @pipeToLoop(pipeState);\n" \
    "    });\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsPipeToDoReadWriteCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsPipeToDoReadWriteCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsPipeToDoReadWriteCodeLength = 1126;
static const JSC::Intrinsic s_readableStreamInternalsPipeToDoReadWriteCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsPipeToDoReadWriteCode =
    "(function (pipeState)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    @assert(!pipeState.shuttingDown);\n" \
    "\n" \
    "    pipeState.pendingReadPromiseCapability = @newPromiseCapability(@Promise);\n" \
    "    @getByIdDirectPrivate(pipeState.writer, \"readyPromise\").@promise.@then(() => {\n" \
    "        if (pipeState.shuttingDown) {\n" \
    "            pipeState.pendingReadPromiseCapability.@resolve.@call(@undefined, false);\n" \
    "            return;\n" \
    "        }\n" \
    "\n" \
    "        @readableStreamDefaultReaderRead(pipeState.reader).@then((result) => {\n" \
    "            const canWrite = !result.done && @getByIdDirectPrivate(pipeState.writer, \"stream\") !== @undefined;\n" \
    "            pipeState.pendingReadPromiseCapability.@resolve.@call(@undefined, canWrite);\n" \
    "            if (!canWrite)\n" \
    "                return;\n" \
    "\n" \
    "            pipeState.pendingWritePromise = @writableStreamDefaultWriterWrite(pipeState.writer, result.value);\n" \
    "        }, (e) => {\n" \
    "            pipeState.pendingReadPromiseCapability.@resolve.@call(@undefined, false);\n" \
    "        });\n" \
    "    }, (e) => {\n" \
    "        pipeState.pendingReadPromiseCapability.@resolve.@call(@undefined, false);\n" \
    "    });\n" \
    "    return pipeState.pendingReadPromiseCapability.@promise;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsPipeToErrorsMustBePropagatedForwardCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsPipeToErrorsMustBePropagatedForwardCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsPipeToErrorsMustBePropagatedForwardCodeLength = 695;
static const JSC::Intrinsic s_readableStreamInternalsPipeToErrorsMustBePropagatedForwardCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsPipeToErrorsMustBePropagatedForwardCode =
    "(function (pipeState)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    const action = () => {\n" \
    "        pipeState.pendingReadPromiseCapability.@resolve.@call(@undefined, false);\n" \
    "        const error = @getByIdDirectPrivate(pipeState.source, \"storedError\");\n" \
    "        if (!pipeState.preventAbort) {\n" \
    "            @pipeToShutdownWithAction(pipeState, () => @writableStreamAbort(pipeState.destination, error), error);\n" \
    "            return;\n" \
    "        }\n" \
    "        @pipeToShutdown(pipeState, error);\n" \
    "    };\n" \
    "\n" \
    "    if (@getByIdDirectPrivate(pipeState.source, \"state\") === @streamErrored) {\n" \
    "        action();\n" \
    "        return;\n" \
    "    }\n" \
    "\n" \
    "    @getByIdDirectPrivate(pipeState.reader, \"closedPromiseCapability\").@promise.@then(@undefined, action);\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsPipeToErrorsMustBePropagatedBackwardCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsPipeToErrorsMustBePropagatedBackwardCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsPipeToErrorsMustBePropagatedBackwardCodeLength = 602;
static const JSC::Intrinsic s_readableStreamInternalsPipeToErrorsMustBePropagatedBackwardCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsPipeToErrorsMustBePropagatedBackwardCode =
    "(function (pipeState)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    const action = () => {\n" \
    "        const error = @getByIdDirectPrivate(pipeState.destination, \"storedError\");\n" \
    "        if (!pipeState.preventCancel) {\n" \
    "            @pipeToShutdownWithAction(pipeState, () => @readableStreamCancel(pipeState.source, error), error);\n" \
    "            return;\n" \
    "        }\n" \
    "        @pipeToShutdown(pipeState, error);\n" \
    "    };\n" \
    "    if (@getByIdDirectPrivate(pipeState.destination, \"state\") === \"errored\") {\n" \
    "        action();\n" \
    "        return;\n" \
    "    }\n" \
    "    @getByIdDirectPrivate(pipeState.writer, \"closedPromise\").@promise.@then(@undefined, action);\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsPipeToClosingMustBePropagatedForwardCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsPipeToClosingMustBePropagatedForwardCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsPipeToClosingMustBePropagatedForwardCodeLength = 698;
static const JSC::Intrinsic s_readableStreamInternalsPipeToClosingMustBePropagatedForwardCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsPipeToClosingMustBePropagatedForwardCode =
    "(function (pipeState)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    const action = () => {\n" \
    "        pipeState.pendingReadPromiseCapability.@resolve.@call(@undefined, false);\n" \
    "        const error = @getByIdDirectPrivate(pipeState.source, \"storedError\");\n" \
    "        if (!pipeState.preventClose) {\n" \
    "            @pipeToShutdownWithAction(pipeState, () => @writableStreamDefaultWriterCloseWithErrorPropagation(pipeState.writer));\n" \
    "            return;\n" \
    "        }\n" \
    "        @pipeToShutdown(pipeState);\n" \
    "    };\n" \
    "    if (@getByIdDirectPrivate(pipeState.source, \"state\") === @streamClosed) {\n" \
    "        action();\n" \
    "        return;\n" \
    "    }\n" \
    "    @getByIdDirectPrivate(pipeState.reader, \"closedPromiseCapability\").@promise.@then(action, @undefined);\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsPipeToClosingMustBePropagatedBackwardCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsPipeToClosingMustBePropagatedBackwardCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsPipeToClosingMustBePropagatedBackwardCodeLength = 482;
static const JSC::Intrinsic s_readableStreamInternalsPipeToClosingMustBePropagatedBackwardCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsPipeToClosingMustBePropagatedBackwardCode =
    "(function (pipeState)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    if (!@writableStreamCloseQueuedOrInFlight(pipeState.destination) && @getByIdDirectPrivate(pipeState.destination, \"state\") !== \"closed\")\n" \
    "        return;\n" \
    "\n" \
    "    //\n" \
    "\n" \
    "    const error = @makeTypeError(\"closing is propagated backward\");\n" \
    "    if (!pipeState.preventCancel) {\n" \
    "        @pipeToShutdownWithAction(pipeState, () => @readableStreamCancel(pipeState.source, error), error);\n" \
    "        return;\n" \
    "    }\n" \
    "    @pipeToShutdown(pipeState, error);\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsPipeToShutdownWithActionCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsPipeToShutdownWithActionCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsPipeToShutdownWithActionCodeLength = 901;
static const JSC::Intrinsic s_readableStreamInternalsPipeToShutdownWithActionCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsPipeToShutdownWithActionCode =
    "(function (pipeState, action)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    if (pipeState.shuttingDown)\n" \
    "        return;\n" \
    "\n" \
    "    pipeState.shuttingDown = true;\n" \
    "\n" \
    "    const hasError = arguments.length > 2;\n" \
    "    const error = arguments[2];\n" \
    "    const finalize = () => {\n" \
    "        const promise = action();\n" \
    "        promise.@then(() => {\n" \
    "            if (hasError)\n" \
    "                @pipeToFinalize(pipeState, error);\n" \
    "            else\n" \
    "                @pipeToFinalize(pipeState);\n" \
    "        }, (e)  => {\n" \
    "            @pipeToFinalize(pipeState, e);\n" \
    "        });\n" \
    "    };\n" \
    "\n" \
    "    if (@getByIdDirectPrivate(pipeState.destination, \"state\") === \"writable\" && !@writableStreamCloseQueuedOrInFlight(pipeState.destination)) {\n" \
    "        pipeState.pendingReadPromiseCapability.@promise.@then(() => {\n" \
    "            pipeState.pendingWritePromise.@then(finalize, finalize);\n" \
    "        }, (e) => @pipeToFinalize(pipeState, e));\n" \
    "        return;\n" \
    "    }\n" \
    "\n" \
    "    finalize();\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsPipeToShutdownCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsPipeToShutdownCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsPipeToShutdownCodeLength = 740;
static const JSC::Intrinsic s_readableStreamInternalsPipeToShutdownCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsPipeToShutdownCode =
    "(function (pipeState)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    \n" \
    "    if (pipeState.shuttingDown)\n" \
    "        return;\n" \
    "\n" \
    "    pipeState.shuttingDown = true;\n" \
    "\n" \
    "    const hasError = arguments.length > 1;\n" \
    "    const error = arguments[1];\n" \
    "    const finalize = () => {\n" \
    "        if (hasError)\n" \
    "            @pipeToFinalize(pipeState, error);\n" \
    "        else\n" \
    "            @pipeToFinalize(pipeState);\n" \
    "    };\n" \
    "\n" \
    "    if (@getByIdDirectPrivate(pipeState.destination, \"state\") === \"writable\" && !@writableStreamCloseQueuedOrInFlight(pipeState.destination)) {\n" \
    "        pipeState.pendingReadPromiseCapability.@promise.@then(() => {\n" \
    "            pipeState.pendingWritePromise.@then(finalize, finalize);\n" \
    "        }, (e) => @pipeToFinalize(pipeState, e));\n" \
    "        return;\n" \
    "    }\n" \
    "    finalize();\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsPipeToFinalizeCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsPipeToFinalizeCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsPipeToFinalizeCodeLength = 375;
static const JSC::Intrinsic s_readableStreamInternalsPipeToFinalizeCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsPipeToFinalizeCode =
    "(function (pipeState)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    @writableStreamDefaultWriterRelease(pipeState.writer);\n" \
    "    @readableStreamReaderGenericRelease(pipeState.reader);\n" \
    "\n" \
    "    //\n" \
    "    pipeState.finalized = true;\n" \
    "\n" \
    "    if (arguments.length > 1)\n" \
    "        pipeState.promiseCapability.@reject.@call(@undefined, arguments[1]);\n" \
    "    else\n" \
    "        pipeState.promiseCapability.@resolve.@call();\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsReadableStreamTeeCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsReadableStreamTeeCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsReadableStreamTeeCodeLength = 1671;
static const JSC::Intrinsic s_readableStreamInternalsReadableStreamTeeCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsReadableStreamTeeCode =
    "(function (stream, shouldClone)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    @assert(@isReadableStream(stream));\n" \
    "    @assert(typeof(shouldClone) === \"boolean\");\n" \
    "\n" \
    "    const reader = new @ReadableStreamDefaultReader(stream);\n" \
    "\n" \
    "    const teeState = {\n" \
    "        closedOrErrored: false,\n" \
    "        canceled1: false,\n" \
    "        canceled2: false,\n" \
    "        reason1: @undefined,\n" \
    "        reason2: @undefined,\n" \
    "    };\n" \
    "\n" \
    "    teeState.cancelPromiseCapability = @newPromiseCapability(@Promise);\n" \
    "\n" \
    "    const pullFunction = @readableStreamTeePullFunction(teeState, reader, shouldClone);\n" \
    "\n" \
    "    const branch1Source = { };\n" \
    "    @putByIdDirectPrivate(branch1Source, \"pull\", pullFunction);\n" \
    "    @putByIdDirectPrivate(branch1Source, \"cancel\", @readableStreamTeeBranch1CancelFunction(teeState, stream));\n" \
    "\n" \
    "    const branch2Source = { };\n" \
    "    @putByIdDirectPrivate(branch2Source, \"pull\", pullFunction);\n" \
    "    @putByIdDirectPrivate(branch2Source, \"cancel\", @readableStreamTeeBranch2CancelFunction(teeState, stream));\n" \
    "\n" \
    "    const branch1 = new @ReadableStream(branch1Source);\n" \
    "    const branch2 = new @ReadableStream(branch2Source);\n" \
    "\n" \
    "    @getByIdDirectPrivate(reader, \"closedPromiseCapability\").@promise.@then(@undefined, function(e) {\n" \
    "        if (teeState.closedOrErrored)\n" \
    "            return;\n" \
    "        @readableStreamDefaultControllerError(branch1.@readableStreamController, e);\n" \
    "        @readableStreamDefaultControllerError(branch2.@readableStreamController, e);\n" \
    "        teeState.closedOrErrored = true;\n" \
    "        if (!teeState.canceled1 || !teeState.canceled2)\n" \
    "            teeState.cancelPromiseCapability.@resolve.@call();\n" \
    "    });\n" \
    "\n" \
    "    //\n" \
    "    teeState.branch1 = branch1;\n" \
    "    teeState.branch2 = branch2;\n" \
    "\n" \
    "    return [branch1, branch2];\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsReadableStreamTeePullFunctionCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsReadableStreamTeePullFunctionCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsReadableStreamTeePullFunctionCodeLength = 1275;
static const JSC::Intrinsic s_readableStreamInternalsReadableStreamTeePullFunctionCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsReadableStreamTeePullFunctionCode =
    "(function (teeState, reader, shouldClone)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    return function() {\n" \
    "        @Promise.prototype.@then.@call(@readableStreamDefaultReaderRead(reader), function(result) {\n" \
    "            @assert(@isObject(result));\n" \
    "            @assert(typeof result.done === \"boolean\");\n" \
    "            if (result.done && !teeState.closedOrErrored) {\n" \
    "                if (!teeState.canceled1)\n" \
    "                    @readableStreamDefaultControllerClose(teeState.branch1.@readableStreamController);\n" \
    "                if (!teeState.canceled2)\n" \
    "                    @readableStreamDefaultControllerClose(teeState.branch2.@readableStreamController);\n" \
    "                teeState.closedOrErrored = true;\n" \
    "                if (!teeState.canceled1 || !teeState.canceled2)\n" \
    "                    teeState.cancelPromiseCapability.@resolve.@call();\n" \
    "            }\n" \
    "            if (teeState.closedOrErrored)\n" \
    "                return;\n" \
    "            if (!teeState.canceled1)\n" \
    "                @readableStreamDefaultControllerEnqueue(teeState.branch1.@readableStreamController, result.value);\n" \
    "            if (!teeState.canceled2)\n" \
    "                @readableStreamDefaultControllerEnqueue(teeState.branch2.@readableStreamController, shouldClone ? @structuredCloneForStream(result.value) : result.value);\n" \
    "        });\n" \
    "    }\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsReadableStreamTeeBranch1CancelFunctionCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsReadableStreamTeeBranch1CancelFunctionCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsReadableStreamTeeBranch1CancelFunctionCodeLength = 456;
static const JSC::Intrinsic s_readableStreamInternalsReadableStreamTeeBranch1CancelFunctionCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsReadableStreamTeeBranch1CancelFunctionCode =
    "(function (teeState, stream)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    return function(r) {\n" \
    "        teeState.canceled1 = true;\n" \
    "        teeState.reason1 = r;\n" \
    "        if (teeState.canceled2) {\n" \
    "            @readableStreamCancel(stream, [teeState.reason1, teeState.reason2]).@then(\n" \
    "                teeState.cancelPromiseCapability.@resolve,\n" \
    "                teeState.cancelPromiseCapability.@reject);\n" \
    "        }\n" \
    "        return teeState.cancelPromiseCapability.@promise;\n" \
    "    }\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsReadableStreamTeeBranch2CancelFunctionCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsReadableStreamTeeBranch2CancelFunctionCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsReadableStreamTeeBranch2CancelFunctionCodeLength = 456;
static const JSC::Intrinsic s_readableStreamInternalsReadableStreamTeeBranch2CancelFunctionCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsReadableStreamTeeBranch2CancelFunctionCode =
    "(function (teeState, stream)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    return function(r) {\n" \
    "        teeState.canceled2 = true;\n" \
    "        teeState.reason2 = r;\n" \
    "        if (teeState.canceled1) {\n" \
    "            @readableStreamCancel(stream, [teeState.reason1, teeState.reason2]).@then(\n" \
    "                teeState.cancelPromiseCapability.@resolve,\n" \
    "                teeState.cancelPromiseCapability.@reject);\n" \
    "        }\n" \
    "        return teeState.cancelPromiseCapability.@promise;\n" \
    "    }\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsIsReadableStreamCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsIsReadableStreamCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsIsReadableStreamCodeLength = 170;
static const JSC::Intrinsic s_readableStreamInternalsIsReadableStreamCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsIsReadableStreamCode =
    "(function (stream)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    //\n" \
    "    //\n" \
    "    //\n" \
    "    return @isObject(stream) && @getByIdDirectPrivate(stream, \"readableStreamController\") !== @undefined;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsIsReadableStreamDefaultReaderCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsIsReadableStreamDefaultReaderCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsIsReadableStreamDefaultReaderCodeLength = 145;
static const JSC::Intrinsic s_readableStreamInternalsIsReadableStreamDefaultReaderCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsIsReadableStreamDefaultReaderCode =
    "(function (reader)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    //\n" \
    "    //\n" \
    "    //\n" \
    "    return @isObject(reader) && !!@getByIdDirectPrivate(reader, \"readRequests\");\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsIsReadableStreamDefaultControllerCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsIsReadableStreamDefaultControllerCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsIsReadableStreamDefaultControllerCodeLength = 168;
static const JSC::Intrinsic s_readableStreamInternalsIsReadableStreamDefaultControllerCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsIsReadableStreamDefaultControllerCode =
    "(function (controller)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    //\n" \
    "    //\n" \
    "    //\n" \
    "    //\n" \
    "    return @isObject(controller) && !!@getByIdDirectPrivate(controller, \"underlyingSource\");\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsAssignToStreamCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsAssignToStreamCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsAssignToStreamCodeLength = 2945;
static const JSC::Intrinsic s_readableStreamInternalsAssignToStreamCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsAssignToStreamCode =
    "(function (stream, sink) {\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    //\n" \
    "    const underlyingSource = @getByIdDirectPrivate(stream, \"underlyingSource\");\n" \
    "\n" \
    "    //\n" \
    "    if (underlyingSource) {\n" \
    "        var originalClose = underlyingSource.close;\n" \
    "        var reader;\n" \
    "        var close = (reason) => {\n" \
    "            originalClose && originalClose(reason);\n" \
    "            try {\n" \
    "                reader && reader.releaseLock();\n" \
    "            } catch (e) {}\n" \
    "            @readableStreamClose(stream, reason);\n" \
    "            \n" \
    "        }\n" \
    "        var pull = underlyingSource.pull;\n" \
    "\n" \
    "        if (!pull) {\n" \
    "            close();\n" \
    "            return;\n" \
    "        }\n" \
    "\n" \
    "        if (!@isCallable(pull)) {\n" \
    "            close();\n" \
    "            @throwTypeError(\"pull is not a function\");\n" \
    "            return;\n" \
    "        }\n" \
    "       \n" \
    "        @putByIdDirectPrivate(stream, \"readableStreamController\", sink);\n" \
    "        @putByIdDirectPrivate(stream, \"start\", @undefined);\n" \
    "        @putByIdDirectPrivate(stream, \"underlyingSource\", @undefined);\n" \
    "\n" \
    "        const highWaterMark = @getByIdDirectPrivate(stream, \"highWaterMark\");\n" \
    "\n" \
    "        if (highWaterMark) {\n" \
    "            sink.start({\n" \
    "                highWaterMark,\n" \
    "            });\n" \
    "        }\n" \
    "\n" \
    "        @startDirectStream.@call(sink, stream, pull, close);\n" \
    "    \n" \
    "        \n" \
    "        //\n" \
    "        reader = stream.getReader();\n" \
    "\n" \
    "        pull(sink);\n" \
    "        return;\n" \
    "    }\n" \
    "\n" \
    "   \n" \
    "    return (async function() {\n" \
    "        \"use strict\";\n" \
    "\n" \
    "        var didClose = false;\n" \
    "        try {\n" \
    "            var reader = stream.getReader();\n" \
    "\n" \
    "            var many = reader.readMany();\n" \
    "            if (many && @isPromise(many)) {\n" \
    "                many = await many;\n" \
    "            }\n" \
    "            if (many.done) {\n" \
    "                didClose = true;\n" \
    "                sink.end();\n" \
    "                return;\n" \
    "            }\n" \
    "\n" \
    "            \n" \
    "            var wroteCount = many.value.length;\n" \
    "            const highWaterMark = @getByIdDirectPrivate(stream, \"highWaterMark\");\n" \
    "\n" \
    "            if (highWaterMark)\n" \
    "                sink.start({highWaterMark});\n" \
    "\n" \
    "            for (var i = 0, values = many.value, length = many.value.length; i < length; i++) {\n" \
    "                sink.write(values[i]);\n" \
    "            }\n" \
    "\n" \
    "            var streamState = @getByIdDirectPrivate(stream, \"state\");\n" \
    "\n" \
    "\n" \
    "            if (streamState === @streamClosed) {\n" \
    "                didClose = true;\n" \
    "                return sink.end();\n" \
    "            }\n" \
    "\n" \
    "            if (wroteCount > 0) {\n" \
    "                sink.drain();\n" \
    "            }\n" \
    "            \n" \
    "            while (true) {\n" \
    "                var result = await reader.read();\n" \
    "\n" \
    "                if (result.done) {\n" \
    "                    didClose = true;\n" \
    "                    return sink.end();\n" \
    "                }\n" \
    "\n" \
    "                sink.write(result.value);\n" \
    "            }\n" \
    "        } catch (e) {\n" \
    "            if (sink && !didClose) {\n" \
    "                didClose = true;\n" \
    "                try {\n" \
    "                    sink.close();\n" \
    "                } catch(j) {\n" \
    "                    throw j;\n" \
    "                }\n" \
    "            }\n" \
    "\n" \
    "            throw e;\n" \
    "        }\n" \
    "    })();\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsHandleDirectStreamErrorCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsHandleDirectStreamErrorCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsHandleDirectStreamErrorCodeLength = 840;
static const JSC::Intrinsic s_readableStreamInternalsHandleDirectStreamErrorCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsHandleDirectStreamErrorCode =
    "(function (e) {\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    var controller = this;\n" \
    "    var sink = controller.@sink;\n" \
    "    if (sink) {\n" \
    "        @putByIdDirectPrivate(controller, \"sink\", @undefined);\n" \
    "        try {\n" \
    "            sink.close(e);\n" \
    "        } catch (f) {}\n" \
    "    }\n" \
    "\n" \
    "    this.error = this.drain = this.write = this.close = this.end = @onReadableStreamDirectControllerClosed;\n" \
    "\n" \
    "    if (typeof this.@underlyingSource.close === 'function') {\n" \
    "        try {\n" \
    "            this.@underlyingSource.close.@call(this.@underlyingSource, e);\n" \
    "        } catch (e) {\n" \
    "        }\n" \
    "    }\n" \
    "\n" \
    "    try {\n" \
    "        var pend = controller._pendingRead;\n" \
    "        if (pend) {\n" \
    "            controller._pendingRead = @undefined;\n" \
    "            @rejectPromise(pend, e);\n" \
    "        }\n" \
    "    } catch (f) {}\n" \
    "   var stream = controller.@controlledReadableStream;\n" \
    "    if (stream) @readableStreamError(stream, e);\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsHandleDirectStreamErrorRejectCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsHandleDirectStreamErrorRejectCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsHandleDirectStreamErrorRejectCodeLength = 96;
static const JSC::Intrinsic s_readableStreamInternalsHandleDirectStreamErrorRejectCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsHandleDirectStreamErrorRejectCode =
    "(function (e) {\n" \
    "    @handleDirectStreamError.@call(this, e);\n" \
    "    return @Promise.@reject(e);\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsOnPullDirectStreamCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsOnPullDirectStreamCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsOnPullDirectStreamCodeLength = 1701;
static const JSC::Intrinsic s_readableStreamInternalsOnPullDirectStreamCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsOnPullDirectStreamCode =
    "(function (controller)\n" \
    "{\n" \
    "    \n" \
    "    \"use strict\";\n" \
    "\n" \
    "    var stream = controller.@controlledReadableStream;\n" \
    "    if (!stream || @getByIdDirectPrivate(stream, \"state\") !== @streamReadable)\n" \
    "        return;\n" \
    "\n" \
    "    //\n" \
    "    //\n" \
    "    //\n" \
    "    if (controller._deferClose === -1) {\n" \
    "        return;\n" \
    "    }\n" \
    "\n" \
    "    \n" \
    "    controller._deferClose = -1;\n" \
    "    controller._deferDrain = -1;\n" \
    "    var deferClose;\n" \
    "    var deferDrain;\n" \
    "\n" \
    "    //\n" \
    "    //\n" \
    "    //\n" \
    "    //\n" \
    "    //\n" \
    "    //\n" \
    "    try {\n" \
    "        var result = controller.@underlyingSource.pull(\n" \
    "            controller,\n" \
    "        );\n" \
    "\n" \
    "        if (result && @isPromise(result)) {\n" \
    "            if (controller._handleError === @undefined) {\n" \
    "                controller._handleError = @handleDirectStreamErrorReject.bind(controller);\n" \
    "            }\n" \
    "\n" \
    "            @Promise.prototype.catch.@call(result, controller._handleError);\n" \
    "        }\n" \
    "    } catch(e) {\n" \
    "        return @handleDirectStreamErrorReject.@call(controller, e);\n" \
    "    } finally {\n" \
    "        deferClose = controller._deferClose;\n" \
    "        deferDrain = controller._deferDrain;\n" \
    "        controller._deferDrain = controller._deferClose = 0;\n" \
    "    }\n" \
    "    \n" \
    "   \n" \
    "    var promiseToReturn;\n" \
    "   \n" \
    "\n" \
    "    if (controller._pendingRead === @undefined) {\n" \
    "        controller._pendingRead = promiseToReturn = @newPromise();\n" \
    "    } else {\n" \
    "        promiseToReturn = @readableStreamAddReadRequest(stream);\n" \
    "    }\n" \
    "\n" \
    "\n" \
    "    //\n" \
    "    //\n" \
    "    if (deferClose === 1) {\n" \
    "        var reason = controller._deferCloseReason;\n" \
    "        controller._deferCloseReason = @undefined;\n" \
    "        @onCloseDirectStream.@call(controller, reason);\n" \
    "        return promiseToReturn;\n" \
    "    }\n" \
    "\n" \
    "    //\n" \
    "    if (deferDrain === 1) {\n" \
    "        @onDrainDirectStream.@call(controller);\n" \
    "    }\n" \
    "    \n" \
    "\n" \
    "    return promiseToReturn;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsNoopDoneFunctionCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsNoopDoneFunctionCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsNoopDoneFunctionCodeLength = 81;
static const JSC::Intrinsic s_readableStreamInternalsNoopDoneFunctionCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsNoopDoneFunctionCode =
    "(function () {\n" \
    "    return @Promise.@resolve({value: @undefined, done: true});\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsOnReadableStreamDirectControllerClosedCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsOnReadableStreamDirectControllerClosedCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsOnReadableStreamDirectControllerClosedCodeLength = 111;
static const JSC::Intrinsic s_readableStreamInternalsOnReadableStreamDirectControllerClosedCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsOnReadableStreamDirectControllerClosedCode =
    "(function (reason)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    @throwTypeError(\"ReadableStreamDirectController is now closed\");\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsOnCloseDirectStreamCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsOnCloseDirectStreamCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsOnCloseDirectStreamCodeLength = 2405;
static const JSC::Intrinsic s_readableStreamInternalsOnCloseDirectStreamCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsOnCloseDirectStreamCode =
    "(function (reason)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    var stream = this.@controlledReadableStream;\n" \
    "    if (!stream || @getByIdDirectPrivate(stream, \"state\") !== @streamReadable)\n" \
    "        return;\n" \
    "\n" \
    "    if (this._deferClose !== 0) {\n" \
    "        this._deferClose = 1;\n" \
    "        this._deferCloseReason = reason;\n" \
    "        return;\n" \
    "    }\n" \
    "\n" \
    "    @putByIdDirectPrivate(stream, \"state\", @streamClosing);\n" \
    "    if (typeof this.@underlyingSource.close === 'function') {\n" \
    "        try {\n" \
    "            this.@underlyingSource.close.@call(this.@underlyingSource, reason);\n" \
    "        } catch (e) {\n" \
    "            \n" \
    "        }\n" \
    "    }\n" \
    "\n" \
    "    var drained;\n" \
    "    try {\n" \
    "        drained = this.@sink.end();\n" \
    "        @putByIdDirectPrivate(this, \"sink\", @undefined);\n" \
    "    } catch (e) {\n" \
    "        if (this._pendingRead) {\n" \
    "            var read = this._pendingRead;\n" \
    "            this._pendingRead = @undefined;\n" \
    "            @rejectPromise(read, e);\n" \
    "        }\n" \
    "        @readableStreamError(stream, e);\n" \
    "        return;\n" \
    "    }\n" \
    "\n" \
    "    this.error = this.drain = this.write = this.close = this.end = @onReadableStreamDirectControllerClosed;\n" \
    "\n" \
    "    var reader = @getByIdDirectPrivate(stream, \"reader\");\n" \
    "\n" \
    "    if (reader && @isReadableStreamDefaultReader(reader)) {\n" \
    "        var _pendingRead = this._pendingRead;\n" \
    "        if (_pendingRead && @isPromise(_pendingRead) && drained?.byteLength) {\n" \
    "            this._pendingRead = @undefined;\n" \
    "            @fulfillPromise(_pendingRead, {value: drained, done: false});\n" \
    "            @readableStreamClose(stream);\n" \
    "            return;\n" \
    "        }\n" \
    "    }\n" \
    "\n" \
    "    if (drained?.byteLength) {\n" \
    "        var requests = @getByIdDirectPrivate(reader, \"readRequests\");\n" \
    "        if (requests?.isNotEmpty()) {\n" \
    "            @readableStreamFulfillReadRequest(stream, drained, false);\n" \
    "            @readableStreamClose(stream);\n" \
    "            return;\n" \
    "        }\n" \
    "        \n" \
    "        @putByIdDirectPrivate(stream, \"state\", @streamReadable);\n" \
    "        this.@pull = () => {\n" \
    "            var thisResult = @createFulfilledPromise({value: drained, done: false});\n" \
    "            drained = @undefined;\n" \
    "            @readableStreamClose(stream);\n" \
    "            stream = @undefined;\n" \
    "            return thisResult;\n" \
    "        };\n" \
    "    } else if (this._pendingRead) {\n" \
    "        var read = this._pendingRead;\n" \
    "        this._pendingRead = @undefined;\n" \
    "        @putByIdDirectPrivate(this, \"pull\", @noopDoneFunction);\n" \
    "        @fulfillPromise(read, {value: @undefined, done: true});\n" \
    "    }\n" \
    "\n" \
    "    @readableStreamClose(stream);\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsOnDrainDirectStreamCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsOnDrainDirectStreamCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsOnDrainDirectStreamCodeLength = 990;
static const JSC::Intrinsic s_readableStreamInternalsOnDrainDirectStreamCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsOnDrainDirectStreamCode =
    "(function ()\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    var stream = this.@controlledReadableStream;\n" \
    "    var reader = @getByIdDirectPrivate(stream, \"reader\");\n" \
    "    if (!reader || !@isReadableStreamDefaultReader(reader)) {\n" \
    "        return;\n" \
    "    }\n" \
    "\n" \
    "    var _pendingRead = this._pendingRead;\n" \
    "    this._pendingRead = @undefined;\n" \
    "    if (_pendingRead && @isPromise(_pendingRead)) {\n" \
    "        var drained = this.@sink.drain();\n" \
    "        if (drained?.byteLength) {\n" \
    "            this._pendingRead = @getByIdDirectPrivate(stream, \"readRequests\")?.shift();\n" \
    "            @fulfillPromise(_pendingRead, {value: drained, done: false});\n" \
    "        } else {\n" \
    "            this._pendingRead = _pendingRead;\n" \
    "        }\n" \
    "    } else if (@getByIdDirectPrivate(stream, \"readRequests\")?.isNotEmpty()) {\n" \
    "        var drained = this.@sink.drain();\n" \
    "        if (drained?.byteLength) {\n" \
    "            @readableStreamFulfillReadRequest(stream, drained, false);\n" \
    "        }\n" \
    "    } else if (this._deferDrain === -1) {\n" \
    "        this._deferDrain = 1;\n" \
    "    }\n" \
    "    \n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsInitializeTextStreamCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsInitializeTextStreamCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsInitializeTextStreamCodeLength = 3957;
static const JSC::Intrinsic s_readableStreamInternalsInitializeTextStreamCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsInitializeTextStreamCode =
    "(function (underlyingSource, highWaterMark)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    var sink;\n" \
    "    var fifo = @createFIFO();\n" \
    "    var hasString = false;\n" \
    "    var hasBuffer = false;\n" \
    "    var rope = '';\n" \
    "    var estimatedLength = @toLength(0);\n" \
    "    var closingPromise = @newPromise();\n" \
    "    var calledDone = false;\n" \
    "    var isView = @ArrayBuffer.@isView;\n" \
    "    \n" \
    "\n" \
    "    sink = {\n" \
    "        start() {\n" \
    "\n" \
    "        },\n" \
    "        write(chunk) {\n" \
    "            if (typeof chunk === 'string') {\n" \
    "                var chunkLength = @toLength(chunk.length);\n" \
    "                if (chunkLength > 0) {\n" \
    "                    rope += chunk;\n" \
    "                    hasString = true;\n" \
    "                     //\n" \
    "                    estimatedLength += chunkLength;\n" \
    "                   \n" \
    "                }\n" \
    "\n" \
    "                return chunkLength;\n" \
    "            }\n" \
    "\n" \
    "            if (!chunk || !@isObject(chunk) || !((isView(chunk)) || chunk instanceof @ArrayBuffer)) {\n" \
    "                @throwTypeError(\"Expected text, ArrayBuffer or ArrayBufferView\");\n" \
    "            }\n" \
    "\n" \
    "            const byteLength = @toLength(chunk.byteLength);\n" \
    "            if (byteLength > 0) {\n" \
    "                hasBuffer = true;\n" \
    "                if (rope.length > 0) {\n" \
    "                    fifo.push(rope);\n" \
    "                    rope = '';\n" \
    "                }\n" \
    "                fifo.push(chunk);\n" \
    "            }\n" \
    "            estimatedLength += byteLength;\n" \
    "            return byteLength;\n" \
    "\n" \
    "        },\n" \
    "\n" \
    "        drain() {\n" \
    "            return 0;\n" \
    "        },\n" \
    "\n" \
    "        end() {\n" \
    "            if (calledDone) {\n" \
    "                return \"\";\n" \
    "            }\n" \
    "            return sink.fulfill();\n" \
    "        },\n" \
    "\n" \
    "        fulfill() {\n" \
    "            calledDone = true;\n" \
    "            const result = sink.finishInternal();\n" \
    "            @fulfillPromise(closingPromise, result);\n" \
    "            return result;\n" \
    "        },\n" \
    "\n" \
    "        finishInternal() {\n" \
    "            if (!hasString && !hasBuffer) {\n" \
    "                return \"\";\n" \
    "            }\n" \
    "\n" \
    "            if (hasString && !hasBuffer) {\n" \
    "                return rope;\n" \
    "            }\n" \
    "\n" \
    "            if (hasBuffer && !hasString) {\n" \
    "                return new globalThis.TextDecoder().decode(\n" \
    "                    globalThis.Bun.concatArrayBuffers(fifo.toArray(false)));\n" \
    "            }\n" \
    "\n" \
    "            //\n" \
    "            var array = fifo.toArray(false);\n" \
    "            \n" \
    "            var arrayBufferSink = new globalThis.Bun.ArrayBufferSink();\n" \
    "            arrayBufferSink.start({\n" \
    "                highWaterMark: estimatedLength,\n" \
    "                asUint8Array: true,\n" \
    "            });\n" \
    "            for (let item of array) {\n" \
    "                arrayBufferSink.write(\n" \
    "                    item\n" \
    "                );\n" \
    "            }\n" \
    "            if (rope.length > 0) {\n" \
    "                arrayBufferSink.write(rope);\n" \
    "            }\n" \
    "            \n" \
    "            //\n" \
    "            return new globalThis.TextDecoder().decode(\n" \
    "                arrayBufferSink.end()\n" \
    "            );\n" \
    "        },\n" \
    "\n" \
    "        close() {\n" \
    "            try {\n" \
    "                if (!calledDone) {\n" \
    "                    calledDone = true;\n" \
    "                    sink.fulfill();\n" \
    "                }\n" \
    "            } catch(e) {\n" \
    "\n" \
    "            } finally {\n" \
    "                rope = '';\n" \
    "                hasString = false;\n" \
    "                hasBuffer = false;\n" \
    "                estimatedLength = 0;\n" \
    "            }\n" \
    "        }\n" \
    "    };\n" \
    "\n" \
    "    var controller = {\n" \
    "        @underlyingSource: underlyingSource,\n" \
    "        @pull: @onPullDirectStream,\n" \
    "        @controlledReadableStream: this,\n" \
    "        @sink: sink,\n" \
    "        close: @onCloseDirectStream,\n" \
    "        write: sink.write,\n" \
    "        error: @handleDirectStreamError,\n" \
    "        end: @onCloseDirectStream,\n" \
    "        @close: @onCloseDirectStream,\n" \
    "        drain: @onDrainDirectStream,\n" \
    "        _pendingRead: @undefined,\n" \
    "        _deferClose: 0,\n" \
    "        _deferDrain: 0,\n" \
    "        _deferCloseReason: @undefined,\n" \
    "        _handleError: @undefined,\n" \
    "    };\n" \
    "   \n" \
    "    \n" \
    "    @putByIdDirectPrivate(this, \"readableStreamController\", controller);\n" \
    "    @putByIdDirectPrivate(this, \"underlyingSource\", @undefined);\n" \
    "    @putByIdDirectPrivate(this, \"start\", @undefined);\n" \
    "    return closingPromise;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsInitializeArrayStreamCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsInitializeArrayStreamCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsInitializeArrayStreamCodeLength = 1496;
static const JSC::Intrinsic s_readableStreamInternalsInitializeArrayStreamCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsInitializeArrayStreamCode =
    "(function (underlyingSource, highWaterMark)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    var array = [];\n" \
    "    var closingPromise = @newPromise();\n" \
    "    var calledDone = false;\n" \
    "    \n" \
    "    function fulfill() {\n" \
    "        calledDone = true;\n" \
    "        @fulfillPromise(closingPromise, array);\n" \
    "        return array;\n" \
    "    }\n" \
    "\n" \
    "    var sink = {\n" \
    "        start() {\n" \
    "\n" \
    "        },\n" \
    "        write(chunk) {\n" \
    "            array.push(chunk);\n" \
    "            return chunk.length;\n" \
    "        },\n" \
    "\n" \
    "        drain() {\n" \
    "            return 0;\n" \
    "        },\n" \
    "\n" \
    "        end() {\n" \
    "            if (calledDone) {\n" \
    "                return [];\n" \
    "            }\n" \
    "            return fulfill();\n" \
    "        },\n" \
    "\n" \
    "        close() {\n" \
    "            if (!calledDone) {\n" \
    "                fulfill();\n" \
    "            }\n" \
    "        }\n" \
    "    };\n" \
    "\n" \
    "    var controller = {\n" \
    "        @underlyingSource: underlyingSource,\n" \
    "        @pull: @onPullDirectStream,\n" \
    "        @controlledReadableStream: this,\n" \
    "        @sink: sink,\n" \
    "        close: @onCloseDirectStream,\n" \
    "        write: sink.write,\n" \
    "        error: @handleDirectStreamError,\n" \
    "        end: @onCloseDirectStream,\n" \
    "        @close: @onCloseDirectStream,\n" \
    "        drain: @onDrainDirectStream,\n" \
    "        _pendingRead: @undefined,\n" \
    "        _deferClose: 0,\n" \
    "        _deferDrain: 0,\n" \
    "        _deferCloseReason: @undefined,\n" \
    "        _handleError: @undefined,\n" \
    "    };\n" \
    "   \n" \
    "    \n" \
    "    @putByIdDirectPrivate(this, \"readableStreamController\", controller);\n" \
    "    @putByIdDirectPrivate(this, \"underlyingSource\", @undefined);\n" \
    "    @putByIdDirectPrivate(this, \"start\", @undefined);\n" \
    "    return closingPromise;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsInitializeArrayBufferStreamCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsInitializeArrayBufferStreamCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsInitializeArrayBufferStreamCodeLength = 1086;
static const JSC::Intrinsic s_readableStreamInternalsInitializeArrayBufferStreamCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsInitializeArrayBufferStreamCode =
    "(function (underlyingSource, highWaterMark)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    //\n" \
    "    //\n" \
    "    //\n" \
    "    \n" \
    "    var opts = highWaterMark && typeof highWaterMark === 'number' ? {highWaterMark, stream: true, asUint8Array: true} : {stream: true, asUint8Array: true};\n" \
    "    var sink = new globalThis.Bun.ArrayBufferSink();\n" \
    "    sink.start(opts);\n" \
    "\n" \
    "    var controller = {\n" \
    "        @underlyingSource: underlyingSource,\n" \
    "        @pull: @onPullDirectStream,\n" \
    "        @controlledReadableStream: this,\n" \
    "        @sink: sink,\n" \
    "        close: @onCloseDirectStream,\n" \
    "        write: sink.write.bind(sink),\n" \
    "        error: @handleDirectStreamError,\n" \
    "        end: @onCloseDirectStream,\n" \
    "        @close: @onCloseDirectStream,\n" \
    "        drain: @onDrainDirectStream,\n" \
    "        _pendingRead: @undefined,\n" \
    "        _deferClose: 0,\n" \
    "        _deferDrain: 0,\n" \
    "        _deferCloseReason: @undefined,\n" \
    "        _handleError: @undefined,\n" \
    "    };\n" \
    "   \n" \
    "    \n" \
    "    @putByIdDirectPrivate(this, \"readableStreamController\", controller);\n" \
    "    @putByIdDirectPrivate(this, \"underlyingSource\", @undefined);\n" \
    "    @putByIdDirectPrivate(this, \"start\", @undefined);\n" \
    "    \n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsReadableStreamErrorCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsReadableStreamErrorCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsReadableStreamErrorCodeLength = 1266;
static const JSC::Intrinsic s_readableStreamInternalsReadableStreamErrorCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsReadableStreamErrorCode =
    "(function (stream, error)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    @assert(@isReadableStream(stream));\n" \
    "    @assert(@getByIdDirectPrivate(stream, \"state\") === @streamReadable);\n" \
    "    @putByIdDirectPrivate(stream, \"state\", @streamErrored);\n" \
    "    @putByIdDirectPrivate(stream, \"storedError\", error);\n" \
    "\n" \
    "    const reader = @getByIdDirectPrivate(stream, \"reader\");\n" \
    "\n" \
    "    if (!reader)\n" \
    "        return;\n" \
    "\n" \
    "        if (@isReadableStreamDefaultReader(reader)) {\n" \
    "        const requests = @getByIdDirectPrivate(reader, \"readRequests\");\n" \
    "        @putByIdDirectPrivate(reader, \"readRequests\", @createFIFO());\n" \
    "        for (var request = requests.shift(); request; request = requests.shift())\n" \
    "            @rejectPromise(request, error);\n" \
    "    } else {\n" \
    "        @assert(@isReadableStreamBYOBReader(reader));\n" \
    "        const requests = @getByIdDirectPrivate(reader, \"readIntoRequests\");\n" \
    "        @putByIdDirectPrivate(reader, \"readIntoRequests\", @createFIFO());\n" \
    "        for (var request = requests.shift(); request; request = requests.shift())\n" \
    "            @rejectPromise(request, error);\n" \
    "    }\n" \
    "\n" \
    "    @getByIdDirectPrivate(reader, \"closedPromiseCapability\").@reject.@call(@undefined, error);\n" \
    "    const promise = @getByIdDirectPrivate(reader, \"closedPromiseCapability\").@promise;\n" \
    "    @markPromiseAsHandled(promise);\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsReadableStreamDefaultControllerShouldCallPullCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsReadableStreamDefaultControllerShouldCallPullCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsReadableStreamDefaultControllerShouldCallPullCodeLength = 690;
static const JSC::Intrinsic s_readableStreamInternalsReadableStreamDefaultControllerShouldCallPullCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsReadableStreamDefaultControllerShouldCallPullCode =
    "(function (controller)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    const stream = @getByIdDirectPrivate(controller, \"controlledReadableStream\");\n" \
    "    \n" \
    "    if (!@readableStreamDefaultControllerCanCloseOrEnqueue(controller))\n" \
    "        return false;\n" \
    "    if (!(@getByIdDirectPrivate(controller, \"started\") === 1))\n" \
    "        return false;\n" \
    "    if ((!@isReadableStreamLocked(stream) || !@getByIdDirectPrivate(@getByIdDirectPrivate(stream, \"reader\"), \"readRequests\")?.isNotEmpty()) && @readableStreamDefaultControllerGetDesiredSize(controller) <= 0)\n" \
    "        return false;\n" \
    "    const desiredSize = @readableStreamDefaultControllerGetDesiredSize(controller);\n" \
    "    @assert(desiredSize !== null);\n" \
    "    return desiredSize > 0;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsReadableStreamDefaultControllerCallPullIfNeededCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsReadableStreamDefaultControllerCallPullIfNeededCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsReadableStreamDefaultControllerCallPullIfNeededCodeLength = 1272;
static const JSC::Intrinsic s_readableStreamInternalsReadableStreamDefaultControllerCallPullIfNeededCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsReadableStreamDefaultControllerCallPullIfNeededCode =
    "(function (controller)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    //\n" \
    "    const stream = @getByIdDirectPrivate(controller, \"controlledReadableStream\");\n" \
    "\n" \
    "    if (!@readableStreamDefaultControllerCanCloseOrEnqueue(controller))\n" \
    "        return;\n" \
    "    if (!(@getByIdDirectPrivate(controller, \"started\") === 1))\n" \
    "        return;\n" \
    "    if ((!@isReadableStreamLocked(stream) || !@getByIdDirectPrivate(@getByIdDirectPrivate(stream, \"reader\"), \"readRequests\")?.isNotEmpty()) && @readableStreamDefaultControllerGetDesiredSize(controller) <= 0)\n" \
    "        return;\n" \
    "\n" \
    "    if (@getByIdDirectPrivate(controller, \"pulling\")) {\n" \
    "        @putByIdDirectPrivate(controller, \"pullAgain\", true);\n" \
    "        return;\n" \
    "    }\n" \
    "\n" \
    "    \n" \
    "    @assert(!@getByIdDirectPrivate(controller, \"pullAgain\"));\n" \
    "    @putByIdDirectPrivate(controller, \"pulling\", true);\n" \
    "\n" \
    "    @getByIdDirectPrivate(controller, \"pullAlgorithm\").@call(@undefined).@then(function() {\n" \
    "        @putByIdDirectPrivate(controller, \"pulling\", false);\n" \
    "        if (@getByIdDirectPrivate(controller, \"pullAgain\")) {\n" \
    "            @putByIdDirectPrivate(controller, \"pullAgain\", false);\n" \
    "            \n" \
    "            @readableStreamDefaultControllerCallPullIfNeeded(controller);\n" \
    "        }\n" \
    "    }, function(error) {\n" \
    "        @readableStreamDefaultControllerError(controller, error);\n" \
    "    });\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsIsReadableStreamLockedCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsIsReadableStreamLockedCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsIsReadableStreamLockedCodeLength = 136;
static const JSC::Intrinsic s_readableStreamInternalsIsReadableStreamLockedCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsIsReadableStreamLockedCode =
    "(function (stream)\n" \
    "{\n" \
    "   \"use strict\";\n" \
    "\n" \
    "    @assert(@isReadableStream(stream));\n" \
    "    return !!@getByIdDirectPrivate(stream, \"reader\");\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsReadableStreamDefaultControllerGetDesiredSizeCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsReadableStreamDefaultControllerGetDesiredSizeCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsReadableStreamDefaultControllerGetDesiredSizeCodeLength = 416;
static const JSC::Intrinsic s_readableStreamInternalsReadableStreamDefaultControllerGetDesiredSizeCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsReadableStreamDefaultControllerGetDesiredSizeCode =
    "(function (controller)\n" \
    "{\n" \
    "   \"use strict\";\n" \
    "\n" \
    "    const stream = @getByIdDirectPrivate(controller, \"controlledReadableStream\");\n" \
    "    const state = @getByIdDirectPrivate(stream, \"state\");\n" \
    "\n" \
    "    if (state === @streamErrored)\n" \
    "        return null;\n" \
    "    if (state === @streamClosed)\n" \
    "        return 0;\n" \
    "\n" \
    "    return @getByIdDirectPrivate(controller, \"strategy\").highWaterMark - @getByIdDirectPrivate(controller, \"queue\").size;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsReadableStreamReaderGenericCancelCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsReadableStreamReaderGenericCancelCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsReadableStreamReaderGenericCancelCodeLength = 197;
static const JSC::Intrinsic s_readableStreamInternalsReadableStreamReaderGenericCancelCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsReadableStreamReaderGenericCancelCode =
    "(function (reader, reason)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    const stream = @getByIdDirectPrivate(reader, \"ownerReadableStream\");\n" \
    "    @assert(!!stream);\n" \
    "    return @readableStreamCancel(stream, reason);\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsReadableStreamCancelCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsReadableStreamCancelCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsReadableStreamCancelCodeLength = 534;
static const JSC::Intrinsic s_readableStreamInternalsReadableStreamCancelCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsReadableStreamCancelCode =
    "(function (stream, reason)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    @putByIdDirectPrivate(stream, \"disturbed\", true);\n" \
    "    const state = @getByIdDirectPrivate(stream, \"state\");\n" \
    "    if (state === @streamClosed)\n" \
    "        return @Promise.@resolve();\n" \
    "    if (state === @streamErrored)\n" \
    "        return @Promise.@reject(@getByIdDirectPrivate(stream, \"storedError\"));\n" \
    "    @readableStreamClose(stream);\n" \
    "\n" \
    "    var controller = @getByIdDirectPrivate(stream, \"readableStreamController\");\n" \
    "    return controller.@cancel(controller, reason).@then(function() {  });\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsReadableStreamDefaultControllerCancelCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsReadableStreamDefaultControllerCancelCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsReadableStreamDefaultControllerCancelCodeLength = 207;
static const JSC::Intrinsic s_readableStreamInternalsReadableStreamDefaultControllerCancelCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsReadableStreamDefaultControllerCancelCode =
    "(function (controller, reason)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    @putByIdDirectPrivate(controller, \"queue\", @newQueue());\n" \
    "    return @getByIdDirectPrivate(controller, \"cancelAlgorithm\").@call(@undefined, reason);\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsReadableStreamDefaultControllerPullCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsReadableStreamDefaultControllerPullCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsReadableStreamDefaultControllerPullCodeLength = 758;
static const JSC::Intrinsic s_readableStreamInternalsReadableStreamDefaultControllerPullCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsReadableStreamDefaultControllerPullCode =
    "(function (controller)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    var queue  = @getByIdDirectPrivate(controller, \"queue\");\n" \
    "    if (queue.content.isNotEmpty()) {\n" \
    "        const chunk = @dequeueValue(queue);\n" \
    "        if (@getByIdDirectPrivate(controller, \"closeRequested\") && queue.content.isEmpty())\n" \
    "            @readableStreamClose(@getByIdDirectPrivate(controller, \"controlledReadableStream\"));\n" \
    "        else\n" \
    "            @readableStreamDefaultControllerCallPullIfNeeded(controller);\n" \
    "\n" \
    "        return @createFulfilledPromise({ value: chunk, done: false });\n" \
    "    }\n" \
    "    const pendingPromise = @readableStreamAddReadRequest(@getByIdDirectPrivate(controller, \"controlledReadableStream\"));\n" \
    "    @readableStreamDefaultControllerCallPullIfNeeded(controller);\n" \
    "    return pendingPromise;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsReadableStreamDefaultControllerCloseCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsReadableStreamDefaultControllerCloseCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsReadableStreamDefaultControllerCloseCodeLength = 351;
static const JSC::Intrinsic s_readableStreamInternalsReadableStreamDefaultControllerCloseCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsReadableStreamDefaultControllerCloseCode =
    "(function (controller)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    @assert(@readableStreamDefaultControllerCanCloseOrEnqueue(controller));\n" \
    "    @putByIdDirectPrivate(controller, \"closeRequested\", true);\n" \
    "    if (@getByIdDirectPrivate(controller, \"queue\")?.content?.isEmpty())\n" \
    "        @readableStreamClose(@getByIdDirectPrivate(controller, \"controlledReadableStream\"));\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsReadableStreamCloseCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsReadableStreamCloseCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsReadableStreamCloseCodeLength = 875;
static const JSC::Intrinsic s_readableStreamInternalsReadableStreamCloseCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsReadableStreamCloseCode =
    "(function (stream)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    @assert(@getByIdDirectPrivate(stream, \"state\") === @streamReadable);\n" \
    "    @putByIdDirectPrivate(stream, \"state\", @streamClosed);\n" \
    "    if (!@getByIdDirectPrivate(stream, \"reader\"))\n" \
    "        return;\n" \
    "\n" \
    "    if (@isReadableStreamDefaultReader(@getByIdDirectPrivate(stream, \"reader\"))) {\n" \
    "        const requests = @getByIdDirectPrivate(@getByIdDirectPrivate(stream, \"reader\"), \"readRequests\");\n" \
    "        if (requests.isNotEmpty()) {\n" \
    "            @putByIdDirectPrivate(@getByIdDirectPrivate(stream, \"reader\"), \"readRequests\", @createFIFO());\n" \
    "        \n" \
    "            for (var request = requests.shift(); request; request = requests.shift())\n" \
    "                @fulfillPromise(request, { value: @undefined, done: true });\n" \
    "        }\n" \
    "    }\n" \
    "\n" \
    "    @getByIdDirectPrivate(@getByIdDirectPrivate(stream, \"reader\"), \"closedPromiseCapability\").@resolve.@call();\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsReadableStreamFulfillReadRequestCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsReadableStreamFulfillReadRequestCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsReadableStreamFulfillReadRequestCodeLength = 231;
static const JSC::Intrinsic s_readableStreamInternalsReadableStreamFulfillReadRequestCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsReadableStreamFulfillReadRequestCode =
    "(function (stream, chunk, done)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    const readRequest = @getByIdDirectPrivate(@getByIdDirectPrivate(stream, \"reader\"), \"readRequests\").shift();\n" \
    "    @fulfillPromise(readRequest, { value: chunk, done: done });\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsReadableStreamDefaultControllerEnqueueCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsReadableStreamDefaultControllerEnqueueCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsReadableStreamDefaultControllerEnqueueCodeLength = 993;
static const JSC::Intrinsic s_readableStreamInternalsReadableStreamDefaultControllerEnqueueCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsReadableStreamDefaultControllerEnqueueCode =
    "(function (controller, chunk)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    const stream = @getByIdDirectPrivate(controller, \"controlledReadableStream\");\n" \
    "    //\n" \
    "    @assert(@readableStreamDefaultControllerCanCloseOrEnqueue(controller));\n" \
    "\n" \
    "    if (@isReadableStreamLocked(stream) && @getByIdDirectPrivate(@getByIdDirectPrivate(stream, \"reader\"), \"readRequests\")?.isNotEmpty()) {\n" \
    "        @readableStreamFulfillReadRequest(stream, chunk, false);\n" \
    "        @readableStreamDefaultControllerCallPullIfNeeded(controller);\n" \
    "        return;\n" \
    "    }\n" \
    "\n" \
    "    try {\n" \
    "        let chunkSize = 1;\n" \
    "        if (@getByIdDirectPrivate(controller, \"strategy\").size !== @undefined)\n" \
    "            chunkSize = @getByIdDirectPrivate(controller, \"strategy\").size(chunk);\n" \
    "        @enqueueValueWithSize(@getByIdDirectPrivate(controller, \"queue\"), chunk, chunkSize);\n" \
    "    }\n" \
    "    catch(error) {\n" \
    "        @readableStreamDefaultControllerError(controller, error);\n" \
    "        throw error;\n" \
    "    }\n" \
    "    @readableStreamDefaultControllerCallPullIfNeeded(controller);\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsReadableStreamDefaultReaderReadCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsReadableStreamDefaultReaderReadCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsReadableStreamDefaultReaderReadCodeLength = 649;
static const JSC::Intrinsic s_readableStreamInternalsReadableStreamDefaultReaderReadCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsReadableStreamDefaultReaderReadCode =
    "(function (reader)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    const stream = @getByIdDirectPrivate(reader, \"ownerReadableStream\");\n" \
    "    @assert(!!stream);\n" \
    "    const state = @getByIdDirectPrivate(stream, \"state\");\n" \
    "\n" \
    "    @putByIdDirectPrivate(stream, \"disturbed\", true);\n" \
    "    if (state === @streamClosed)\n" \
    "        return @createFulfilledPromise({ value: @undefined, done: true });\n" \
    "    if (state === @streamErrored)\n" \
    "        return @Promise.@reject(@getByIdDirectPrivate(stream, \"storedError\"));\n" \
    "    @assert(state === @streamReadable);\n" \
    "\n" \
    "    return @getByIdDirectPrivate(stream, \"readableStreamController\").@pull(@getByIdDirectPrivate(stream, \"readableStreamController\"));\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsReadableStreamAddReadRequestCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsReadableStreamAddReadRequestCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsReadableStreamAddReadRequestCodeLength = 373;
static const JSC::Intrinsic s_readableStreamInternalsReadableStreamAddReadRequestCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsReadableStreamAddReadRequestCode =
    "(function (stream)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    @assert(@isReadableStreamDefaultReader(@getByIdDirectPrivate(stream, \"reader\")));\n" \
    "    @assert(@getByIdDirectPrivate(stream, \"state\") == @streamReadable);\n" \
    "\n" \
    "    const readRequest = @newPromise();\n" \
    "    \n" \
    "    @getByIdDirectPrivate(@getByIdDirectPrivate(stream, \"reader\"), \"readRequests\").push(readRequest);\n" \
    "\n" \
    "    return readRequest;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsIsReadableStreamDisturbedCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsIsReadableStreamDisturbedCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsIsReadableStreamDisturbedCodeLength = 138;
static const JSC::Intrinsic s_readableStreamInternalsIsReadableStreamDisturbedCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsIsReadableStreamDisturbedCode =
    "(function (stream)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    @assert(@isReadableStream(stream));\n" \
    "    return @getByIdDirectPrivate(stream, \"disturbed\");\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsReadableStreamReaderGenericReleaseCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsReadableStreamReaderGenericReleaseCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsReadableStreamReaderGenericReleaseCodeLength = 968;
static const JSC::Intrinsic s_readableStreamInternalsReadableStreamReaderGenericReleaseCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsReadableStreamReaderGenericReleaseCode =
    "(function (reader)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    @assert(!!@getByIdDirectPrivate(reader, \"ownerReadableStream\"));\n" \
    "    @assert(@getByIdDirectPrivate(@getByIdDirectPrivate(reader, \"ownerReadableStream\"), \"reader\") === reader);\n" \
    "\n" \
    "    if (@getByIdDirectPrivate(@getByIdDirectPrivate(reader, \"ownerReadableStream\"), \"state\") === @streamReadable)\n" \
    "        @getByIdDirectPrivate(reader, \"closedPromiseCapability\").@reject.@call(@undefined, @makeTypeError(\"releasing lock of reader whose stream is still in readable state\"));\n" \
    "    else\n" \
    "        @putByIdDirectPrivate(reader, \"closedPromiseCapability\", { @promise: @newHandledRejectedPromise(@makeTypeError(\"reader released lock\")) });\n" \
    "\n" \
    "    const promise = @getByIdDirectPrivate(reader, \"closedPromiseCapability\").@promise;\n" \
    "    @markPromiseAsHandled(promise);\n" \
    "    @putByIdDirectPrivate(@getByIdDirectPrivate(reader, \"ownerReadableStream\"), \"reader\", @undefined);\n" \
    "    @putByIdDirectPrivate(reader, \"ownerReadableStream\", @undefined);\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsReadableStreamDefaultControllerCanCloseOrEnqueueCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsReadableStreamDefaultControllerCanCloseOrEnqueueCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsReadableStreamDefaultControllerCanCloseOrEnqueueCodeLength = 229;
static const JSC::Intrinsic s_readableStreamInternalsReadableStreamDefaultControllerCanCloseOrEnqueueCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsReadableStreamDefaultControllerCanCloseOrEnqueueCode =
    "(function (controller)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    return !@getByIdDirectPrivate(controller, \"closeRequested\") && @getByIdDirectPrivate(@getByIdDirectPrivate(controller, \"controlledReadableStream\"), \"state\") === @streamReadable;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsLazyLoadStreamCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsLazyLoadStreamCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsLazyLoadStreamCodeLength = 2853;
static const JSC::Intrinsic s_readableStreamInternalsLazyLoadStreamCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsLazyLoadStreamCode =
    "(function (stream, autoAllocateChunkSize) {\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    var nativeType = @getByIdDirectPrivate(stream, \"bunNativeType\");\n" \
    "    var nativePtr = @getByIdDirectPrivate(stream, \"bunNativePtr\");\n" \
    "    var cached = @lazyStreamPrototypeMap;\n" \
    "    var Prototype = cached.@get(nativeType);\n" \
    "    if (Prototype === @undefined) {\n" \
    "        var [pull, start, cancel, setClose, deinit] = @lazyLoad(nativeType);\n" \
    "        var closer = [false];\n" \
    "        var handleResult;\n" \
    "        function handleNativeReadableStreamPromiseResult(val) {\n" \
    "            \"use strict\";\n" \
    "            var {c, v} = this;\n" \
    "            this.c = @undefined;\n" \
    "            this.v = @undefined;\n" \
    "            handleResult(val, c, v);\n" \
    "        }\n" \
    "     \n" \
    "        handleResult = function handleResult(result, controller, view) {\n" \
    "            \"use strict\";\n" \
    "\n" \
    "            if (result && @isPromise(result)) {\n" \
    "                return result.then(handleNativeReadableStreamPromiseResult.bind({c: controller, v: view}), (err) => controller.error(err));\n" \
    "            } else if (result !== false) {\n" \
    "                if (view && view.byteLength === result) {\n" \
    "                    controller.byobRequest.respondWithNewView(view);\n" \
    "                } else {\n" \
    "                    controller.byobRequest.respond(result);\n" \
    "                }\n" \
    "            }\n" \
    "\n" \
    "            if (closer[0] || result === false) {\n" \
    "                @enqueueJob(() => controller.close());\n" \
    "                closer[0] = false;\n" \
    "            }\n" \
    "        };\n" \
    "\n" \
    "        Prototype = class NativeReadableStreamSource {\n" \
    "            constructor(tag, autoAllocateChunkSize) {\n" \
    "                this.pull = this.pull_.bind(tag);\n" \
    "                this.cancel = this.cancel_.bind(tag);\n" \
    "                this.autoAllocateChunkSize = autoAllocateChunkSize;\n" \
    "            }\n" \
    "\n" \
    "            pull;\n" \
    "            cancel;\n" \
    "\n" \
    "            type = \"bytes\";\n" \
    "            autoAllocateChunkSize = 0;\n" \
    "\n" \
    "            static startSync = start;\n" \
    "            \n" \
    "            pull_(controller) {\n" \
    "                closer[0] = false;\n" \
    "                var result;\n" \
    "\n" \
    "                const view = controller.byobRequest.view;\n" \
    "                try {\n" \
    "                    result = pull(this, view, closer);\n" \
    "                } catch(err) {\n" \
    "                    return controller.error(err);\n" \
    "                }\n" \
    "\n" \
    "                return handleResult(result, controller, view);\n" \
    "            }\n" \
    "\n" \
    "            cancel_(reason) {\n" \
    "                cancel(this, reason);\n" \
    "            }\n" \
    "            static deinit = deinit;\n" \
    "            static registry = new FinalizationRegistry(deinit);\n" \
    "        }\n" \
    "        cached.@set(nativeType, Prototype);\n" \
    "    }\n" \
    "\n" \
    "    const chunkSize = Prototype.startSync(nativePtr, autoAllocateChunkSize);\n" \
    "\n" \
    "    //\n" \
    "    if (chunkSize === 0) {\n" \
    "        @readableStreamClose(stream);\n" \
    "        return null;\n" \
    "    }\n" \
    "    var instance = new Prototype(nativePtr, chunkSize);\n" \
    "    Prototype.registry.register(instance, nativePtr);\n" \
    "    return instance;\n" \
    "})\n" \
;


#define DEFINE_BUILTIN_GENERATOR(codeName, functionName, overriddenName, argumentCount) \
JSC::FunctionExecutable* codeName##Generator(JSC::VM& vm) \
{\
    JSVMClientData* clientData = static_cast<JSVMClientData*>(vm.clientData); \
    return clientData->builtinFunctions().readableStreamInternalsBuiltins().codeName##Executable()->link(vm, nullptr, clientData->builtinFunctions().readableStreamInternalsBuiltins().codeName##Source(), std::nullopt, s_##codeName##Intrinsic); \
}
WEBCORE_FOREACH_READABLESTREAMINTERNALS_BUILTIN_CODE(DEFINE_BUILTIN_GENERATOR)
#undef DEFINE_BUILTIN_GENERATOR


} // namespace WebCore
