
// GENERATED CODE - DO NOT MODIFY BY HAND
// Generated by make codegen
#include "root.h"

#include "ZigGlobalObject.h"

#include <JavaScriptCore/DOMJITAbstractHeap.h>
#include "DOMJITIDLConvert.h"
#include "DOMJITIDLType.h"
#include "DOMJITIDLTypeFilter.h"
#include "DOMJITHelpers.h"
#include <JavaScriptCore/DFGAbstractHeap.h>

#include "JSDOMConvertBufferSource.h"
#include "ZigGeneratedClasses.h"

namespace WebCore {

using namespace JSC;
using namespace Zig;

extern "C" void* SHA1Class__construct(JSC::JSGlobalObject*, JSC::CallFrame*);
JSC_DECLARE_CUSTOM_GETTER(jsSHA1Constructor);
extern "C" void SHA1Class__finalize(void*);

extern "C" JSC::EncodedJSValue SHA1Prototype__getByteLength(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(SHA1Prototype__byteLengthGetterWrap);

extern "C" EncodedJSValue SHA1Prototype__digest(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(SHA1Prototype__digestCallback);

extern "C" EncodedJSValue SHA1Prototype__update(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(SHA1Prototype__updateCallback);

STATIC_ASSERT_ISO_SUBSPACE_SHARABLE(JSSHA1Prototype, JSSHA1Prototype::Base);

static const HashTableValue JSSHA1PrototypeTableValues[] = {
    { "byteLength"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute), NoIntrinsic, { (intptr_t) static_cast<PropertySlot::GetValueFunc>(SHA1Prototype__byteLengthGetterWrap), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "digest"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { (intptr_t) static_cast<RawNativeFunction>(SHA1Prototype__digestCallback), (intptr_t)(0) } },
    { "update"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { (intptr_t) static_cast<RawNativeFunction>(SHA1Prototype__updateCallback), (intptr_t)(0) } }
};

const ClassInfo JSSHA1Prototype::s_info = { "SHA1"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSSHA1Prototype) };

JSC_DEFINE_CUSTOM_GETTER(jsSHA1Constructor, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName))
{
    VM& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    auto* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto* prototype = jsDynamicCast<JSSHA1Prototype*>(JSValue::decode(thisValue));

    if (UNLIKELY(!prototype))
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    return JSValue::encode(globalObject->JSSHA1Constructor());
}

JSC_DEFINE_CUSTOM_GETTER(SHA1Prototype__byteLengthGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSSHA1* thisObject = jsCast<JSSHA1*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = SHA1Prototype__getByteLength(thisObject->wrapped(), globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_HOST_FUNCTION(SHA1Prototype__digestCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSSHA1* thisObject = jsDynamicCast<JSSHA1*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return SHA1Prototype__digest(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(SHA1Prototype__updateCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSSHA1* thisObject = jsDynamicCast<JSSHA1*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return SHA1Prototype__update(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

void JSSHA1Prototype::finishCreation(JSC::VM& vm, JSC::JSGlobalObject* globalObject)
{
    Base::finishCreation(vm);
    reifyStaticProperties(vm, JSSHA1::info(), JSSHA1PrototypeTableValues, *this);
    JSC_TO_STRING_TAG_WITHOUT_TRANSITION();
}

extern "C" JSC_DECLARE_CUSTOM_GETTER(SHA1Class__getByteLengthStatic);
extern "C" JSC_DECLARE_HOST_FUNCTION(SHA1Class__hash);

static const HashTableValue JSSHA1ConstructorTableValues[] = {
    { "byteLength"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute), NoIntrinsic, { (intptr_t) static_cast<PropertySlot::GetValueFunc>(SHA1Class__getByteLengthStatic), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "hash"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { (intptr_t) static_cast<RawNativeFunction>(SHA1Class__hash), (intptr_t)(2) } }
};

void JSSHA1Constructor::finishCreation(VM& vm, JSC::JSGlobalObject* globalObject, JSSHA1Prototype* prototype)
{
    Base::finishCreation(vm, 0, "SHA1"_s, PropertyAdditionMode::WithoutStructureTransition);
    reifyStaticProperties(vm, &JSSHA1Constructor::s_info, JSSHA1ConstructorTableValues, *this);
    ASSERT(inherits(info()));
}

JSSHA1Constructor* JSSHA1Constructor::create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, JSSHA1Prototype* prototype)
{
    JSSHA1Constructor* ptr = new (NotNull, JSC::allocateCell<JSSHA1Constructor>(vm)) JSSHA1Constructor(vm, structure, construct);
    ptr->finishCreation(vm, globalObject, prototype);
    return ptr;
}

JSC::EncodedJSValue JSC_HOST_CALL_ATTRIBUTES JSSHA1Constructor::construct(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame)
{
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    JSC::VM& vm = globalObject->vm();
    JSObject* newTarget = asObject(callFrame->newTarget());
    auto* constructor = globalObject->JSSHA1Constructor();
    Structure* structure = globalObject->JSSHA1Structure();
    if (constructor != newTarget) {
        auto scope = DECLARE_THROW_SCOPE(vm);

        auto* functionGlobalObject = reinterpret_cast<Zig::GlobalObject*>(
            // ShadowRealm functions belong to a different global object.
            getFunctionRealm(globalObject, newTarget));
        RETURN_IF_EXCEPTION(scope, {});
        structure = InternalFunction::createSubclassStructure(
            globalObject,
            newTarget,
            functionGlobalObject->JSSHA1Structure());
    }

    void* ptr = SHA1Class__construct(globalObject, callFrame);

    if (UNLIKELY(!ptr)) {
        return JSValue::encode(JSC::jsUndefined());
    }

    JSSHA1* instance = JSSHA1::create(vm, globalObject, structure, ptr);

    return JSValue::encode(instance);
}

extern "C" EncodedJSValue SHA1__create(Zig::GlobalObject* globalObject, void* ptr)
{
    auto& vm = globalObject->vm();
    JSC::Structure* structure = globalObject->JSSHA1Structure();
    JSSHA1* instance = JSSHA1::create(vm, globalObject, structure, ptr);
    return JSValue::encode(instance);
}

void JSSHA1Constructor::initializeProperties(VM& vm, JSC::JSGlobalObject* globalObject, JSSHA1Prototype* prototype)
{
}

const ClassInfo JSSHA1Constructor::s_info = { "Function"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSSHA1Constructor) };

extern "C" EncodedJSValue SHA1__getConstructor(Zig::GlobalObject* globalObject)
{
    return JSValue::encode(globalObject->JSSHA1Constructor());
}

JSSHA1::~JSSHA1()
{
    if (m_ctx) {
        SHA1Class__finalize(m_ctx);
    }
}
void JSSHA1::destroy(JSCell* cell)
{
    static_cast<JSSHA1*>(cell)->JSSHA1::~JSSHA1();
}

const ClassInfo JSSHA1::s_info = { "SHA1"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSSHA1) };

void JSSHA1::finishCreation(VM& vm)
{
    Base::finishCreation(vm);
    ASSERT(inherits(info()));
}

JSSHA1* JSSHA1::create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* ctx)
{
    JSSHA1* ptr = new (NotNull, JSC::allocateCell<JSSHA1>(vm)) JSSHA1(vm, structure, ctx);
    ptr->finishCreation(vm);
    return ptr;
}

extern "C" void* SHA1__fromJS(JSC::EncodedJSValue value)
{
    JSSHA1* object = JSC::jsDynamicCast<JSSHA1*>(JSValue::decode(value));
    if (!object)
        return nullptr;

    return object->wrapped();
}

extern "C" bool SHA1__dangerouslySetPtr(JSC::EncodedJSValue value, void* ptr)
{
    JSSHA1* object = JSC::jsDynamicCast<JSSHA1*>(JSValue::decode(value));
    if (!object)
        return false;

    object->m_ctx = ptr;
    return true;
}

extern "C" const size_t SHA1__ptrOffset = JSSHA1::offsetOfWrapped();

void JSSHA1::analyzeHeap(JSCell* cell, HeapAnalyzer& analyzer)
{
    auto* thisObject = jsCast<JSSHA1*>(cell);
    if (void* wrapped = thisObject->wrapped()) {
        // if (thisObject->scriptExecutionContext())
        //     analyzer.setLabelForCell(cell, "url " + thisObject->scriptExecutionContext()->url().string());
    }
    Base::analyzeHeap(cell, analyzer);
}

JSObject* JSSHA1::createPrototype(VM& vm, JSDOMGlobalObject* globalObject)
{
    return JSSHA1Prototype::create(vm, globalObject, JSSHA1Prototype::createStructure(vm, globalObject, globalObject->objectPrototype()));
}
extern "C" void* MD5Class__construct(JSC::JSGlobalObject*, JSC::CallFrame*);
JSC_DECLARE_CUSTOM_GETTER(jsMD5Constructor);
extern "C" void MD5Class__finalize(void*);

extern "C" JSC::EncodedJSValue MD5Prototype__getByteLength(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(MD5Prototype__byteLengthGetterWrap);

extern "C" EncodedJSValue MD5Prototype__digest(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(MD5Prototype__digestCallback);

extern "C" EncodedJSValue MD5Prototype__update(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(MD5Prototype__updateCallback);

STATIC_ASSERT_ISO_SUBSPACE_SHARABLE(JSMD5Prototype, JSMD5Prototype::Base);

static const HashTableValue JSMD5PrototypeTableValues[] = {
    { "byteLength"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute), NoIntrinsic, { (intptr_t) static_cast<PropertySlot::GetValueFunc>(MD5Prototype__byteLengthGetterWrap), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "digest"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { (intptr_t) static_cast<RawNativeFunction>(MD5Prototype__digestCallback), (intptr_t)(0) } },
    { "update"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { (intptr_t) static_cast<RawNativeFunction>(MD5Prototype__updateCallback), (intptr_t)(0) } }
};

const ClassInfo JSMD5Prototype::s_info = { "MD5"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSMD5Prototype) };

JSC_DEFINE_CUSTOM_GETTER(jsMD5Constructor, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName))
{
    VM& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    auto* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto* prototype = jsDynamicCast<JSMD5Prototype*>(JSValue::decode(thisValue));

    if (UNLIKELY(!prototype))
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    return JSValue::encode(globalObject->JSMD5Constructor());
}

JSC_DEFINE_CUSTOM_GETTER(MD5Prototype__byteLengthGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSMD5* thisObject = jsCast<JSMD5*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = MD5Prototype__getByteLength(thisObject->wrapped(), globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_HOST_FUNCTION(MD5Prototype__digestCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSMD5* thisObject = jsDynamicCast<JSMD5*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return MD5Prototype__digest(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(MD5Prototype__updateCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSMD5* thisObject = jsDynamicCast<JSMD5*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return MD5Prototype__update(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

void JSMD5Prototype::finishCreation(JSC::VM& vm, JSC::JSGlobalObject* globalObject)
{
    Base::finishCreation(vm);
    reifyStaticProperties(vm, JSMD5::info(), JSMD5PrototypeTableValues, *this);
    JSC_TO_STRING_TAG_WITHOUT_TRANSITION();
}

extern "C" JSC_DECLARE_CUSTOM_GETTER(MD5Class__getByteLengthStatic);
extern "C" JSC_DECLARE_HOST_FUNCTION(MD5Class__hash);

static const HashTableValue JSMD5ConstructorTableValues[] = {
    { "byteLength"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute), NoIntrinsic, { (intptr_t) static_cast<PropertySlot::GetValueFunc>(MD5Class__getByteLengthStatic), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "hash"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { (intptr_t) static_cast<RawNativeFunction>(MD5Class__hash), (intptr_t)(2) } }
};

void JSMD5Constructor::finishCreation(VM& vm, JSC::JSGlobalObject* globalObject, JSMD5Prototype* prototype)
{
    Base::finishCreation(vm, 0, "MD5"_s, PropertyAdditionMode::WithoutStructureTransition);
    reifyStaticProperties(vm, &JSMD5Constructor::s_info, JSMD5ConstructorTableValues, *this);
    ASSERT(inherits(info()));
}

JSMD5Constructor* JSMD5Constructor::create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, JSMD5Prototype* prototype)
{
    JSMD5Constructor* ptr = new (NotNull, JSC::allocateCell<JSMD5Constructor>(vm)) JSMD5Constructor(vm, structure, construct);
    ptr->finishCreation(vm, globalObject, prototype);
    return ptr;
}

JSC::EncodedJSValue JSC_HOST_CALL_ATTRIBUTES JSMD5Constructor::construct(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame)
{
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    JSC::VM& vm = globalObject->vm();
    JSObject* newTarget = asObject(callFrame->newTarget());
    auto* constructor = globalObject->JSMD5Constructor();
    Structure* structure = globalObject->JSMD5Structure();
    if (constructor != newTarget) {
        auto scope = DECLARE_THROW_SCOPE(vm);

        auto* functionGlobalObject = reinterpret_cast<Zig::GlobalObject*>(
            // ShadowRealm functions belong to a different global object.
            getFunctionRealm(globalObject, newTarget));
        RETURN_IF_EXCEPTION(scope, {});
        structure = InternalFunction::createSubclassStructure(
            globalObject,
            newTarget,
            functionGlobalObject->JSMD5Structure());
    }

    void* ptr = MD5Class__construct(globalObject, callFrame);

    if (UNLIKELY(!ptr)) {
        return JSValue::encode(JSC::jsUndefined());
    }

    JSMD5* instance = JSMD5::create(vm, globalObject, structure, ptr);

    return JSValue::encode(instance);
}

extern "C" EncodedJSValue MD5__create(Zig::GlobalObject* globalObject, void* ptr)
{
    auto& vm = globalObject->vm();
    JSC::Structure* structure = globalObject->JSMD5Structure();
    JSMD5* instance = JSMD5::create(vm, globalObject, structure, ptr);
    return JSValue::encode(instance);
}

void JSMD5Constructor::initializeProperties(VM& vm, JSC::JSGlobalObject* globalObject, JSMD5Prototype* prototype)
{
}

const ClassInfo JSMD5Constructor::s_info = { "Function"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSMD5Constructor) };

extern "C" EncodedJSValue MD5__getConstructor(Zig::GlobalObject* globalObject)
{
    return JSValue::encode(globalObject->JSMD5Constructor());
}

JSMD5::~JSMD5()
{
    if (m_ctx) {
        MD5Class__finalize(m_ctx);
    }
}
void JSMD5::destroy(JSCell* cell)
{
    static_cast<JSMD5*>(cell)->JSMD5::~JSMD5();
}

const ClassInfo JSMD5::s_info = { "MD5"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSMD5) };

void JSMD5::finishCreation(VM& vm)
{
    Base::finishCreation(vm);
    ASSERT(inherits(info()));
}

JSMD5* JSMD5::create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* ctx)
{
    JSMD5* ptr = new (NotNull, JSC::allocateCell<JSMD5>(vm)) JSMD5(vm, structure, ctx);
    ptr->finishCreation(vm);
    return ptr;
}

extern "C" void* MD5__fromJS(JSC::EncodedJSValue value)
{
    JSMD5* object = JSC::jsDynamicCast<JSMD5*>(JSValue::decode(value));
    if (!object)
        return nullptr;

    return object->wrapped();
}

extern "C" bool MD5__dangerouslySetPtr(JSC::EncodedJSValue value, void* ptr)
{
    JSMD5* object = JSC::jsDynamicCast<JSMD5*>(JSValue::decode(value));
    if (!object)
        return false;

    object->m_ctx = ptr;
    return true;
}

extern "C" const size_t MD5__ptrOffset = JSMD5::offsetOfWrapped();

void JSMD5::analyzeHeap(JSCell* cell, HeapAnalyzer& analyzer)
{
    auto* thisObject = jsCast<JSMD5*>(cell);
    if (void* wrapped = thisObject->wrapped()) {
        // if (thisObject->scriptExecutionContext())
        //     analyzer.setLabelForCell(cell, "url " + thisObject->scriptExecutionContext()->url().string());
    }
    Base::analyzeHeap(cell, analyzer);
}

JSObject* JSMD5::createPrototype(VM& vm, JSDOMGlobalObject* globalObject)
{
    return JSMD5Prototype::create(vm, globalObject, JSMD5Prototype::createStructure(vm, globalObject, globalObject->objectPrototype()));
}
extern "C" void* MD4Class__construct(JSC::JSGlobalObject*, JSC::CallFrame*);
JSC_DECLARE_CUSTOM_GETTER(jsMD4Constructor);
extern "C" void MD4Class__finalize(void*);

extern "C" JSC::EncodedJSValue MD4Prototype__getByteLength(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(MD4Prototype__byteLengthGetterWrap);

extern "C" EncodedJSValue MD4Prototype__digest(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(MD4Prototype__digestCallback);

extern "C" EncodedJSValue MD4Prototype__update(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(MD4Prototype__updateCallback);

STATIC_ASSERT_ISO_SUBSPACE_SHARABLE(JSMD4Prototype, JSMD4Prototype::Base);

static const HashTableValue JSMD4PrototypeTableValues[] = {
    { "byteLength"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute), NoIntrinsic, { (intptr_t) static_cast<PropertySlot::GetValueFunc>(MD4Prototype__byteLengthGetterWrap), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "digest"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { (intptr_t) static_cast<RawNativeFunction>(MD4Prototype__digestCallback), (intptr_t)(0) } },
    { "update"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { (intptr_t) static_cast<RawNativeFunction>(MD4Prototype__updateCallback), (intptr_t)(0) } }
};

const ClassInfo JSMD4Prototype::s_info = { "MD4"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSMD4Prototype) };

JSC_DEFINE_CUSTOM_GETTER(jsMD4Constructor, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName))
{
    VM& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    auto* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto* prototype = jsDynamicCast<JSMD4Prototype*>(JSValue::decode(thisValue));

    if (UNLIKELY(!prototype))
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    return JSValue::encode(globalObject->JSMD4Constructor());
}

JSC_DEFINE_CUSTOM_GETTER(MD4Prototype__byteLengthGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSMD4* thisObject = jsCast<JSMD4*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = MD4Prototype__getByteLength(thisObject->wrapped(), globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_HOST_FUNCTION(MD4Prototype__digestCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSMD4* thisObject = jsDynamicCast<JSMD4*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return MD4Prototype__digest(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(MD4Prototype__updateCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSMD4* thisObject = jsDynamicCast<JSMD4*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return MD4Prototype__update(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

void JSMD4Prototype::finishCreation(JSC::VM& vm, JSC::JSGlobalObject* globalObject)
{
    Base::finishCreation(vm);
    reifyStaticProperties(vm, JSMD4::info(), JSMD4PrototypeTableValues, *this);
    JSC_TO_STRING_TAG_WITHOUT_TRANSITION();
}

extern "C" JSC_DECLARE_CUSTOM_GETTER(MD4Class__getByteLengthStatic);
extern "C" JSC_DECLARE_HOST_FUNCTION(MD4Class__hash);

static const HashTableValue JSMD4ConstructorTableValues[] = {
    { "byteLength"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute), NoIntrinsic, { (intptr_t) static_cast<PropertySlot::GetValueFunc>(MD4Class__getByteLengthStatic), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "hash"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { (intptr_t) static_cast<RawNativeFunction>(MD4Class__hash), (intptr_t)(2) } }
};

void JSMD4Constructor::finishCreation(VM& vm, JSC::JSGlobalObject* globalObject, JSMD4Prototype* prototype)
{
    Base::finishCreation(vm, 0, "MD4"_s, PropertyAdditionMode::WithoutStructureTransition);
    reifyStaticProperties(vm, &JSMD4Constructor::s_info, JSMD4ConstructorTableValues, *this);
    ASSERT(inherits(info()));
}

JSMD4Constructor* JSMD4Constructor::create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, JSMD4Prototype* prototype)
{
    JSMD4Constructor* ptr = new (NotNull, JSC::allocateCell<JSMD4Constructor>(vm)) JSMD4Constructor(vm, structure, construct);
    ptr->finishCreation(vm, globalObject, prototype);
    return ptr;
}

JSC::EncodedJSValue JSC_HOST_CALL_ATTRIBUTES JSMD4Constructor::construct(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame)
{
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    JSC::VM& vm = globalObject->vm();
    JSObject* newTarget = asObject(callFrame->newTarget());
    auto* constructor = globalObject->JSMD4Constructor();
    Structure* structure = globalObject->JSMD4Structure();
    if (constructor != newTarget) {
        auto scope = DECLARE_THROW_SCOPE(vm);

        auto* functionGlobalObject = reinterpret_cast<Zig::GlobalObject*>(
            // ShadowRealm functions belong to a different global object.
            getFunctionRealm(globalObject, newTarget));
        RETURN_IF_EXCEPTION(scope, {});
        structure = InternalFunction::createSubclassStructure(
            globalObject,
            newTarget,
            functionGlobalObject->JSMD4Structure());
    }

    void* ptr = MD4Class__construct(globalObject, callFrame);

    if (UNLIKELY(!ptr)) {
        return JSValue::encode(JSC::jsUndefined());
    }

    JSMD4* instance = JSMD4::create(vm, globalObject, structure, ptr);

    return JSValue::encode(instance);
}

extern "C" EncodedJSValue MD4__create(Zig::GlobalObject* globalObject, void* ptr)
{
    auto& vm = globalObject->vm();
    JSC::Structure* structure = globalObject->JSMD4Structure();
    JSMD4* instance = JSMD4::create(vm, globalObject, structure, ptr);
    return JSValue::encode(instance);
}

void JSMD4Constructor::initializeProperties(VM& vm, JSC::JSGlobalObject* globalObject, JSMD4Prototype* prototype)
{
}

const ClassInfo JSMD4Constructor::s_info = { "Function"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSMD4Constructor) };

extern "C" EncodedJSValue MD4__getConstructor(Zig::GlobalObject* globalObject)
{
    return JSValue::encode(globalObject->JSMD4Constructor());
}

JSMD4::~JSMD4()
{
    if (m_ctx) {
        MD4Class__finalize(m_ctx);
    }
}
void JSMD4::destroy(JSCell* cell)
{
    static_cast<JSMD4*>(cell)->JSMD4::~JSMD4();
}

const ClassInfo JSMD4::s_info = { "MD4"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSMD4) };

void JSMD4::finishCreation(VM& vm)
{
    Base::finishCreation(vm);
    ASSERT(inherits(info()));
}

JSMD4* JSMD4::create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* ctx)
{
    JSMD4* ptr = new (NotNull, JSC::allocateCell<JSMD4>(vm)) JSMD4(vm, structure, ctx);
    ptr->finishCreation(vm);
    return ptr;
}

extern "C" void* MD4__fromJS(JSC::EncodedJSValue value)
{
    JSMD4* object = JSC::jsDynamicCast<JSMD4*>(JSValue::decode(value));
    if (!object)
        return nullptr;

    return object->wrapped();
}

extern "C" bool MD4__dangerouslySetPtr(JSC::EncodedJSValue value, void* ptr)
{
    JSMD4* object = JSC::jsDynamicCast<JSMD4*>(JSValue::decode(value));
    if (!object)
        return false;

    object->m_ctx = ptr;
    return true;
}

extern "C" const size_t MD4__ptrOffset = JSMD4::offsetOfWrapped();

void JSMD4::analyzeHeap(JSCell* cell, HeapAnalyzer& analyzer)
{
    auto* thisObject = jsCast<JSMD4*>(cell);
    if (void* wrapped = thisObject->wrapped()) {
        // if (thisObject->scriptExecutionContext())
        //     analyzer.setLabelForCell(cell, "url " + thisObject->scriptExecutionContext()->url().string());
    }
    Base::analyzeHeap(cell, analyzer);
}

JSObject* JSMD4::createPrototype(VM& vm, JSDOMGlobalObject* globalObject)
{
    return JSMD4Prototype::create(vm, globalObject, JSMD4Prototype::createStructure(vm, globalObject, globalObject->objectPrototype()));
}
extern "C" void* SHA224Class__construct(JSC::JSGlobalObject*, JSC::CallFrame*);
JSC_DECLARE_CUSTOM_GETTER(jsSHA224Constructor);
extern "C" void SHA224Class__finalize(void*);

extern "C" JSC::EncodedJSValue SHA224Prototype__getByteLength(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(SHA224Prototype__byteLengthGetterWrap);

extern "C" EncodedJSValue SHA224Prototype__digest(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(SHA224Prototype__digestCallback);

extern "C" EncodedJSValue SHA224Prototype__update(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(SHA224Prototype__updateCallback);

STATIC_ASSERT_ISO_SUBSPACE_SHARABLE(JSSHA224Prototype, JSSHA224Prototype::Base);

static const HashTableValue JSSHA224PrototypeTableValues[] = {
    { "byteLength"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute), NoIntrinsic, { (intptr_t) static_cast<PropertySlot::GetValueFunc>(SHA224Prototype__byteLengthGetterWrap), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "digest"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { (intptr_t) static_cast<RawNativeFunction>(SHA224Prototype__digestCallback), (intptr_t)(0) } },
    { "update"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { (intptr_t) static_cast<RawNativeFunction>(SHA224Prototype__updateCallback), (intptr_t)(0) } }
};

const ClassInfo JSSHA224Prototype::s_info = { "SHA224"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSSHA224Prototype) };

JSC_DEFINE_CUSTOM_GETTER(jsSHA224Constructor, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName))
{
    VM& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    auto* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto* prototype = jsDynamicCast<JSSHA224Prototype*>(JSValue::decode(thisValue));

    if (UNLIKELY(!prototype))
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    return JSValue::encode(globalObject->JSSHA224Constructor());
}

JSC_DEFINE_CUSTOM_GETTER(SHA224Prototype__byteLengthGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSSHA224* thisObject = jsCast<JSSHA224*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = SHA224Prototype__getByteLength(thisObject->wrapped(), globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_HOST_FUNCTION(SHA224Prototype__digestCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSSHA224* thisObject = jsDynamicCast<JSSHA224*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return SHA224Prototype__digest(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(SHA224Prototype__updateCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSSHA224* thisObject = jsDynamicCast<JSSHA224*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return SHA224Prototype__update(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

void JSSHA224Prototype::finishCreation(JSC::VM& vm, JSC::JSGlobalObject* globalObject)
{
    Base::finishCreation(vm);
    reifyStaticProperties(vm, JSSHA224::info(), JSSHA224PrototypeTableValues, *this);
    JSC_TO_STRING_TAG_WITHOUT_TRANSITION();
}

extern "C" JSC_DECLARE_CUSTOM_GETTER(SHA224Class__getByteLengthStatic);
extern "C" JSC_DECLARE_HOST_FUNCTION(SHA224Class__hash);

static const HashTableValue JSSHA224ConstructorTableValues[] = {
    { "byteLength"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute), NoIntrinsic, { (intptr_t) static_cast<PropertySlot::GetValueFunc>(SHA224Class__getByteLengthStatic), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "hash"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { (intptr_t) static_cast<RawNativeFunction>(SHA224Class__hash), (intptr_t)(2) } }
};

void JSSHA224Constructor::finishCreation(VM& vm, JSC::JSGlobalObject* globalObject, JSSHA224Prototype* prototype)
{
    Base::finishCreation(vm, 0, "SHA224"_s, PropertyAdditionMode::WithoutStructureTransition);
    reifyStaticProperties(vm, &JSSHA224Constructor::s_info, JSSHA224ConstructorTableValues, *this);
    ASSERT(inherits(info()));
}

JSSHA224Constructor* JSSHA224Constructor::create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, JSSHA224Prototype* prototype)
{
    JSSHA224Constructor* ptr = new (NotNull, JSC::allocateCell<JSSHA224Constructor>(vm)) JSSHA224Constructor(vm, structure, construct);
    ptr->finishCreation(vm, globalObject, prototype);
    return ptr;
}

JSC::EncodedJSValue JSC_HOST_CALL_ATTRIBUTES JSSHA224Constructor::construct(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame)
{
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    JSC::VM& vm = globalObject->vm();
    JSObject* newTarget = asObject(callFrame->newTarget());
    auto* constructor = globalObject->JSSHA224Constructor();
    Structure* structure = globalObject->JSSHA224Structure();
    if (constructor != newTarget) {
        auto scope = DECLARE_THROW_SCOPE(vm);

        auto* functionGlobalObject = reinterpret_cast<Zig::GlobalObject*>(
            // ShadowRealm functions belong to a different global object.
            getFunctionRealm(globalObject, newTarget));
        RETURN_IF_EXCEPTION(scope, {});
        structure = InternalFunction::createSubclassStructure(
            globalObject,
            newTarget,
            functionGlobalObject->JSSHA224Structure());
    }

    void* ptr = SHA224Class__construct(globalObject, callFrame);

    if (UNLIKELY(!ptr)) {
        return JSValue::encode(JSC::jsUndefined());
    }

    JSSHA224* instance = JSSHA224::create(vm, globalObject, structure, ptr);

    return JSValue::encode(instance);
}

extern "C" EncodedJSValue SHA224__create(Zig::GlobalObject* globalObject, void* ptr)
{
    auto& vm = globalObject->vm();
    JSC::Structure* structure = globalObject->JSSHA224Structure();
    JSSHA224* instance = JSSHA224::create(vm, globalObject, structure, ptr);
    return JSValue::encode(instance);
}

void JSSHA224Constructor::initializeProperties(VM& vm, JSC::JSGlobalObject* globalObject, JSSHA224Prototype* prototype)
{
}

const ClassInfo JSSHA224Constructor::s_info = { "Function"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSSHA224Constructor) };

extern "C" EncodedJSValue SHA224__getConstructor(Zig::GlobalObject* globalObject)
{
    return JSValue::encode(globalObject->JSSHA224Constructor());
}

JSSHA224::~JSSHA224()
{
    if (m_ctx) {
        SHA224Class__finalize(m_ctx);
    }
}
void JSSHA224::destroy(JSCell* cell)
{
    static_cast<JSSHA224*>(cell)->JSSHA224::~JSSHA224();
}

const ClassInfo JSSHA224::s_info = { "SHA224"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSSHA224) };

void JSSHA224::finishCreation(VM& vm)
{
    Base::finishCreation(vm);
    ASSERT(inherits(info()));
}

JSSHA224* JSSHA224::create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* ctx)
{
    JSSHA224* ptr = new (NotNull, JSC::allocateCell<JSSHA224>(vm)) JSSHA224(vm, structure, ctx);
    ptr->finishCreation(vm);
    return ptr;
}

extern "C" void* SHA224__fromJS(JSC::EncodedJSValue value)
{
    JSSHA224* object = JSC::jsDynamicCast<JSSHA224*>(JSValue::decode(value));
    if (!object)
        return nullptr;

    return object->wrapped();
}

extern "C" bool SHA224__dangerouslySetPtr(JSC::EncodedJSValue value, void* ptr)
{
    JSSHA224* object = JSC::jsDynamicCast<JSSHA224*>(JSValue::decode(value));
    if (!object)
        return false;

    object->m_ctx = ptr;
    return true;
}

extern "C" const size_t SHA224__ptrOffset = JSSHA224::offsetOfWrapped();

void JSSHA224::analyzeHeap(JSCell* cell, HeapAnalyzer& analyzer)
{
    auto* thisObject = jsCast<JSSHA224*>(cell);
    if (void* wrapped = thisObject->wrapped()) {
        // if (thisObject->scriptExecutionContext())
        //     analyzer.setLabelForCell(cell, "url " + thisObject->scriptExecutionContext()->url().string());
    }
    Base::analyzeHeap(cell, analyzer);
}

JSObject* JSSHA224::createPrototype(VM& vm, JSDOMGlobalObject* globalObject)
{
    return JSSHA224Prototype::create(vm, globalObject, JSSHA224Prototype::createStructure(vm, globalObject, globalObject->objectPrototype()));
}
extern "C" void* SHA512Class__construct(JSC::JSGlobalObject*, JSC::CallFrame*);
JSC_DECLARE_CUSTOM_GETTER(jsSHA512Constructor);
extern "C" void SHA512Class__finalize(void*);

extern "C" JSC::EncodedJSValue SHA512Prototype__getByteLength(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(SHA512Prototype__byteLengthGetterWrap);

extern "C" EncodedJSValue SHA512Prototype__digest(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(SHA512Prototype__digestCallback);

extern "C" EncodedJSValue SHA512Prototype__update(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(SHA512Prototype__updateCallback);

STATIC_ASSERT_ISO_SUBSPACE_SHARABLE(JSSHA512Prototype, JSSHA512Prototype::Base);

static const HashTableValue JSSHA512PrototypeTableValues[] = {
    { "byteLength"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute), NoIntrinsic, { (intptr_t) static_cast<PropertySlot::GetValueFunc>(SHA512Prototype__byteLengthGetterWrap), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "digest"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { (intptr_t) static_cast<RawNativeFunction>(SHA512Prototype__digestCallback), (intptr_t)(0) } },
    { "update"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { (intptr_t) static_cast<RawNativeFunction>(SHA512Prototype__updateCallback), (intptr_t)(0) } }
};

const ClassInfo JSSHA512Prototype::s_info = { "SHA512"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSSHA512Prototype) };

JSC_DEFINE_CUSTOM_GETTER(jsSHA512Constructor, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName))
{
    VM& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    auto* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto* prototype = jsDynamicCast<JSSHA512Prototype*>(JSValue::decode(thisValue));

    if (UNLIKELY(!prototype))
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    return JSValue::encode(globalObject->JSSHA512Constructor());
}

JSC_DEFINE_CUSTOM_GETTER(SHA512Prototype__byteLengthGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSSHA512* thisObject = jsCast<JSSHA512*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = SHA512Prototype__getByteLength(thisObject->wrapped(), globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_HOST_FUNCTION(SHA512Prototype__digestCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSSHA512* thisObject = jsDynamicCast<JSSHA512*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return SHA512Prototype__digest(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(SHA512Prototype__updateCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSSHA512* thisObject = jsDynamicCast<JSSHA512*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return SHA512Prototype__update(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

void JSSHA512Prototype::finishCreation(JSC::VM& vm, JSC::JSGlobalObject* globalObject)
{
    Base::finishCreation(vm);
    reifyStaticProperties(vm, JSSHA512::info(), JSSHA512PrototypeTableValues, *this);
    JSC_TO_STRING_TAG_WITHOUT_TRANSITION();
}

extern "C" JSC_DECLARE_CUSTOM_GETTER(SHA512Class__getByteLengthStatic);
extern "C" JSC_DECLARE_HOST_FUNCTION(SHA512Class__hash);

static const HashTableValue JSSHA512ConstructorTableValues[] = {
    { "byteLength"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute), NoIntrinsic, { (intptr_t) static_cast<PropertySlot::GetValueFunc>(SHA512Class__getByteLengthStatic), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "hash"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { (intptr_t) static_cast<RawNativeFunction>(SHA512Class__hash), (intptr_t)(2) } }
};

void JSSHA512Constructor::finishCreation(VM& vm, JSC::JSGlobalObject* globalObject, JSSHA512Prototype* prototype)
{
    Base::finishCreation(vm, 0, "SHA512"_s, PropertyAdditionMode::WithoutStructureTransition);
    reifyStaticProperties(vm, &JSSHA512Constructor::s_info, JSSHA512ConstructorTableValues, *this);
    ASSERT(inherits(info()));
}

JSSHA512Constructor* JSSHA512Constructor::create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, JSSHA512Prototype* prototype)
{
    JSSHA512Constructor* ptr = new (NotNull, JSC::allocateCell<JSSHA512Constructor>(vm)) JSSHA512Constructor(vm, structure, construct);
    ptr->finishCreation(vm, globalObject, prototype);
    return ptr;
}

JSC::EncodedJSValue JSC_HOST_CALL_ATTRIBUTES JSSHA512Constructor::construct(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame)
{
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    JSC::VM& vm = globalObject->vm();
    JSObject* newTarget = asObject(callFrame->newTarget());
    auto* constructor = globalObject->JSSHA512Constructor();
    Structure* structure = globalObject->JSSHA512Structure();
    if (constructor != newTarget) {
        auto scope = DECLARE_THROW_SCOPE(vm);

        auto* functionGlobalObject = reinterpret_cast<Zig::GlobalObject*>(
            // ShadowRealm functions belong to a different global object.
            getFunctionRealm(globalObject, newTarget));
        RETURN_IF_EXCEPTION(scope, {});
        structure = InternalFunction::createSubclassStructure(
            globalObject,
            newTarget,
            functionGlobalObject->JSSHA512Structure());
    }

    void* ptr = SHA512Class__construct(globalObject, callFrame);

    if (UNLIKELY(!ptr)) {
        return JSValue::encode(JSC::jsUndefined());
    }

    JSSHA512* instance = JSSHA512::create(vm, globalObject, structure, ptr);

    return JSValue::encode(instance);
}

extern "C" EncodedJSValue SHA512__create(Zig::GlobalObject* globalObject, void* ptr)
{
    auto& vm = globalObject->vm();
    JSC::Structure* structure = globalObject->JSSHA512Structure();
    JSSHA512* instance = JSSHA512::create(vm, globalObject, structure, ptr);
    return JSValue::encode(instance);
}

void JSSHA512Constructor::initializeProperties(VM& vm, JSC::JSGlobalObject* globalObject, JSSHA512Prototype* prototype)
{
}

const ClassInfo JSSHA512Constructor::s_info = { "Function"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSSHA512Constructor) };

extern "C" EncodedJSValue SHA512__getConstructor(Zig::GlobalObject* globalObject)
{
    return JSValue::encode(globalObject->JSSHA512Constructor());
}

JSSHA512::~JSSHA512()
{
    if (m_ctx) {
        SHA512Class__finalize(m_ctx);
    }
}
void JSSHA512::destroy(JSCell* cell)
{
    static_cast<JSSHA512*>(cell)->JSSHA512::~JSSHA512();
}

const ClassInfo JSSHA512::s_info = { "SHA512"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSSHA512) };

void JSSHA512::finishCreation(VM& vm)
{
    Base::finishCreation(vm);
    ASSERT(inherits(info()));
}

JSSHA512* JSSHA512::create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* ctx)
{
    JSSHA512* ptr = new (NotNull, JSC::allocateCell<JSSHA512>(vm)) JSSHA512(vm, structure, ctx);
    ptr->finishCreation(vm);
    return ptr;
}

extern "C" void* SHA512__fromJS(JSC::EncodedJSValue value)
{
    JSSHA512* object = JSC::jsDynamicCast<JSSHA512*>(JSValue::decode(value));
    if (!object)
        return nullptr;

    return object->wrapped();
}

extern "C" bool SHA512__dangerouslySetPtr(JSC::EncodedJSValue value, void* ptr)
{
    JSSHA512* object = JSC::jsDynamicCast<JSSHA512*>(JSValue::decode(value));
    if (!object)
        return false;

    object->m_ctx = ptr;
    return true;
}

extern "C" const size_t SHA512__ptrOffset = JSSHA512::offsetOfWrapped();

void JSSHA512::analyzeHeap(JSCell* cell, HeapAnalyzer& analyzer)
{
    auto* thisObject = jsCast<JSSHA512*>(cell);
    if (void* wrapped = thisObject->wrapped()) {
        // if (thisObject->scriptExecutionContext())
        //     analyzer.setLabelForCell(cell, "url " + thisObject->scriptExecutionContext()->url().string());
    }
    Base::analyzeHeap(cell, analyzer);
}

JSObject* JSSHA512::createPrototype(VM& vm, JSDOMGlobalObject* globalObject)
{
    return JSSHA512Prototype::create(vm, globalObject, JSSHA512Prototype::createStructure(vm, globalObject, globalObject->objectPrototype()));
}
extern "C" void* SHA384Class__construct(JSC::JSGlobalObject*, JSC::CallFrame*);
JSC_DECLARE_CUSTOM_GETTER(jsSHA384Constructor);
extern "C" void SHA384Class__finalize(void*);

extern "C" JSC::EncodedJSValue SHA384Prototype__getByteLength(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(SHA384Prototype__byteLengthGetterWrap);

extern "C" EncodedJSValue SHA384Prototype__digest(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(SHA384Prototype__digestCallback);

extern "C" EncodedJSValue SHA384Prototype__update(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(SHA384Prototype__updateCallback);

STATIC_ASSERT_ISO_SUBSPACE_SHARABLE(JSSHA384Prototype, JSSHA384Prototype::Base);

static const HashTableValue JSSHA384PrototypeTableValues[] = {
    { "byteLength"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute), NoIntrinsic, { (intptr_t) static_cast<PropertySlot::GetValueFunc>(SHA384Prototype__byteLengthGetterWrap), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "digest"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { (intptr_t) static_cast<RawNativeFunction>(SHA384Prototype__digestCallback), (intptr_t)(0) } },
    { "update"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { (intptr_t) static_cast<RawNativeFunction>(SHA384Prototype__updateCallback), (intptr_t)(0) } }
};

const ClassInfo JSSHA384Prototype::s_info = { "SHA384"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSSHA384Prototype) };

JSC_DEFINE_CUSTOM_GETTER(jsSHA384Constructor, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName))
{
    VM& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    auto* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto* prototype = jsDynamicCast<JSSHA384Prototype*>(JSValue::decode(thisValue));

    if (UNLIKELY(!prototype))
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    return JSValue::encode(globalObject->JSSHA384Constructor());
}

JSC_DEFINE_CUSTOM_GETTER(SHA384Prototype__byteLengthGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSSHA384* thisObject = jsCast<JSSHA384*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = SHA384Prototype__getByteLength(thisObject->wrapped(), globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_HOST_FUNCTION(SHA384Prototype__digestCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSSHA384* thisObject = jsDynamicCast<JSSHA384*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return SHA384Prototype__digest(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(SHA384Prototype__updateCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSSHA384* thisObject = jsDynamicCast<JSSHA384*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return SHA384Prototype__update(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

void JSSHA384Prototype::finishCreation(JSC::VM& vm, JSC::JSGlobalObject* globalObject)
{
    Base::finishCreation(vm);
    reifyStaticProperties(vm, JSSHA384::info(), JSSHA384PrototypeTableValues, *this);
    JSC_TO_STRING_TAG_WITHOUT_TRANSITION();
}

extern "C" JSC_DECLARE_CUSTOM_GETTER(SHA384Class__getByteLengthStatic);
extern "C" JSC_DECLARE_HOST_FUNCTION(SHA384Class__hash);

static const HashTableValue JSSHA384ConstructorTableValues[] = {
    { "byteLength"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute), NoIntrinsic, { (intptr_t) static_cast<PropertySlot::GetValueFunc>(SHA384Class__getByteLengthStatic), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "hash"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { (intptr_t) static_cast<RawNativeFunction>(SHA384Class__hash), (intptr_t)(2) } }
};

void JSSHA384Constructor::finishCreation(VM& vm, JSC::JSGlobalObject* globalObject, JSSHA384Prototype* prototype)
{
    Base::finishCreation(vm, 0, "SHA384"_s, PropertyAdditionMode::WithoutStructureTransition);
    reifyStaticProperties(vm, &JSSHA384Constructor::s_info, JSSHA384ConstructorTableValues, *this);
    ASSERT(inherits(info()));
}

JSSHA384Constructor* JSSHA384Constructor::create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, JSSHA384Prototype* prototype)
{
    JSSHA384Constructor* ptr = new (NotNull, JSC::allocateCell<JSSHA384Constructor>(vm)) JSSHA384Constructor(vm, structure, construct);
    ptr->finishCreation(vm, globalObject, prototype);
    return ptr;
}

JSC::EncodedJSValue JSC_HOST_CALL_ATTRIBUTES JSSHA384Constructor::construct(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame)
{
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    JSC::VM& vm = globalObject->vm();
    JSObject* newTarget = asObject(callFrame->newTarget());
    auto* constructor = globalObject->JSSHA384Constructor();
    Structure* structure = globalObject->JSSHA384Structure();
    if (constructor != newTarget) {
        auto scope = DECLARE_THROW_SCOPE(vm);

        auto* functionGlobalObject = reinterpret_cast<Zig::GlobalObject*>(
            // ShadowRealm functions belong to a different global object.
            getFunctionRealm(globalObject, newTarget));
        RETURN_IF_EXCEPTION(scope, {});
        structure = InternalFunction::createSubclassStructure(
            globalObject,
            newTarget,
            functionGlobalObject->JSSHA384Structure());
    }

    void* ptr = SHA384Class__construct(globalObject, callFrame);

    if (UNLIKELY(!ptr)) {
        return JSValue::encode(JSC::jsUndefined());
    }

    JSSHA384* instance = JSSHA384::create(vm, globalObject, structure, ptr);

    return JSValue::encode(instance);
}

extern "C" EncodedJSValue SHA384__create(Zig::GlobalObject* globalObject, void* ptr)
{
    auto& vm = globalObject->vm();
    JSC::Structure* structure = globalObject->JSSHA384Structure();
    JSSHA384* instance = JSSHA384::create(vm, globalObject, structure, ptr);
    return JSValue::encode(instance);
}

void JSSHA384Constructor::initializeProperties(VM& vm, JSC::JSGlobalObject* globalObject, JSSHA384Prototype* prototype)
{
}

const ClassInfo JSSHA384Constructor::s_info = { "Function"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSSHA384Constructor) };

extern "C" EncodedJSValue SHA384__getConstructor(Zig::GlobalObject* globalObject)
{
    return JSValue::encode(globalObject->JSSHA384Constructor());
}

JSSHA384::~JSSHA384()
{
    if (m_ctx) {
        SHA384Class__finalize(m_ctx);
    }
}
void JSSHA384::destroy(JSCell* cell)
{
    static_cast<JSSHA384*>(cell)->JSSHA384::~JSSHA384();
}

const ClassInfo JSSHA384::s_info = { "SHA384"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSSHA384) };

void JSSHA384::finishCreation(VM& vm)
{
    Base::finishCreation(vm);
    ASSERT(inherits(info()));
}

JSSHA384* JSSHA384::create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* ctx)
{
    JSSHA384* ptr = new (NotNull, JSC::allocateCell<JSSHA384>(vm)) JSSHA384(vm, structure, ctx);
    ptr->finishCreation(vm);
    return ptr;
}

extern "C" void* SHA384__fromJS(JSC::EncodedJSValue value)
{
    JSSHA384* object = JSC::jsDynamicCast<JSSHA384*>(JSValue::decode(value));
    if (!object)
        return nullptr;

    return object->wrapped();
}

extern "C" bool SHA384__dangerouslySetPtr(JSC::EncodedJSValue value, void* ptr)
{
    JSSHA384* object = JSC::jsDynamicCast<JSSHA384*>(JSValue::decode(value));
    if (!object)
        return false;

    object->m_ctx = ptr;
    return true;
}

extern "C" const size_t SHA384__ptrOffset = JSSHA384::offsetOfWrapped();

void JSSHA384::analyzeHeap(JSCell* cell, HeapAnalyzer& analyzer)
{
    auto* thisObject = jsCast<JSSHA384*>(cell);
    if (void* wrapped = thisObject->wrapped()) {
        // if (thisObject->scriptExecutionContext())
        //     analyzer.setLabelForCell(cell, "url " + thisObject->scriptExecutionContext()->url().string());
    }
    Base::analyzeHeap(cell, analyzer);
}

JSObject* JSSHA384::createPrototype(VM& vm, JSDOMGlobalObject* globalObject)
{
    return JSSHA384Prototype::create(vm, globalObject, JSSHA384Prototype::createStructure(vm, globalObject, globalObject->objectPrototype()));
}
extern "C" void* SHA256Class__construct(JSC::JSGlobalObject*, JSC::CallFrame*);
JSC_DECLARE_CUSTOM_GETTER(jsSHA256Constructor);
extern "C" void SHA256Class__finalize(void*);

extern "C" JSC::EncodedJSValue SHA256Prototype__getByteLength(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(SHA256Prototype__byteLengthGetterWrap);

extern "C" EncodedJSValue SHA256Prototype__digest(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(SHA256Prototype__digestCallback);

extern "C" EncodedJSValue SHA256Prototype__update(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(SHA256Prototype__updateCallback);

STATIC_ASSERT_ISO_SUBSPACE_SHARABLE(JSSHA256Prototype, JSSHA256Prototype::Base);

static const HashTableValue JSSHA256PrototypeTableValues[] = {
    { "byteLength"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute), NoIntrinsic, { (intptr_t) static_cast<PropertySlot::GetValueFunc>(SHA256Prototype__byteLengthGetterWrap), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "digest"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { (intptr_t) static_cast<RawNativeFunction>(SHA256Prototype__digestCallback), (intptr_t)(0) } },
    { "update"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { (intptr_t) static_cast<RawNativeFunction>(SHA256Prototype__updateCallback), (intptr_t)(0) } }
};

const ClassInfo JSSHA256Prototype::s_info = { "SHA256"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSSHA256Prototype) };

JSC_DEFINE_CUSTOM_GETTER(jsSHA256Constructor, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName))
{
    VM& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    auto* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto* prototype = jsDynamicCast<JSSHA256Prototype*>(JSValue::decode(thisValue));

    if (UNLIKELY(!prototype))
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    return JSValue::encode(globalObject->JSSHA256Constructor());
}

JSC_DEFINE_CUSTOM_GETTER(SHA256Prototype__byteLengthGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSSHA256* thisObject = jsCast<JSSHA256*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = SHA256Prototype__getByteLength(thisObject->wrapped(), globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_HOST_FUNCTION(SHA256Prototype__digestCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSSHA256* thisObject = jsDynamicCast<JSSHA256*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return SHA256Prototype__digest(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(SHA256Prototype__updateCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSSHA256* thisObject = jsDynamicCast<JSSHA256*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return SHA256Prototype__update(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

void JSSHA256Prototype::finishCreation(JSC::VM& vm, JSC::JSGlobalObject* globalObject)
{
    Base::finishCreation(vm);
    reifyStaticProperties(vm, JSSHA256::info(), JSSHA256PrototypeTableValues, *this);
    JSC_TO_STRING_TAG_WITHOUT_TRANSITION();
}

extern "C" JSC_DECLARE_CUSTOM_GETTER(SHA256Class__getByteLengthStatic);
extern "C" JSC_DECLARE_HOST_FUNCTION(SHA256Class__hash);

static const HashTableValue JSSHA256ConstructorTableValues[] = {
    { "byteLength"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute), NoIntrinsic, { (intptr_t) static_cast<PropertySlot::GetValueFunc>(SHA256Class__getByteLengthStatic), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "hash"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { (intptr_t) static_cast<RawNativeFunction>(SHA256Class__hash), (intptr_t)(2) } }
};

void JSSHA256Constructor::finishCreation(VM& vm, JSC::JSGlobalObject* globalObject, JSSHA256Prototype* prototype)
{
    Base::finishCreation(vm, 0, "SHA256"_s, PropertyAdditionMode::WithoutStructureTransition);
    reifyStaticProperties(vm, &JSSHA256Constructor::s_info, JSSHA256ConstructorTableValues, *this);
    ASSERT(inherits(info()));
}

JSSHA256Constructor* JSSHA256Constructor::create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, JSSHA256Prototype* prototype)
{
    JSSHA256Constructor* ptr = new (NotNull, JSC::allocateCell<JSSHA256Constructor>(vm)) JSSHA256Constructor(vm, structure, construct);
    ptr->finishCreation(vm, globalObject, prototype);
    return ptr;
}

JSC::EncodedJSValue JSC_HOST_CALL_ATTRIBUTES JSSHA256Constructor::construct(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame)
{
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    JSC::VM& vm = globalObject->vm();
    JSObject* newTarget = asObject(callFrame->newTarget());
    auto* constructor = globalObject->JSSHA256Constructor();
    Structure* structure = globalObject->JSSHA256Structure();
    if (constructor != newTarget) {
        auto scope = DECLARE_THROW_SCOPE(vm);

        auto* functionGlobalObject = reinterpret_cast<Zig::GlobalObject*>(
            // ShadowRealm functions belong to a different global object.
            getFunctionRealm(globalObject, newTarget));
        RETURN_IF_EXCEPTION(scope, {});
        structure = InternalFunction::createSubclassStructure(
            globalObject,
            newTarget,
            functionGlobalObject->JSSHA256Structure());
    }

    void* ptr = SHA256Class__construct(globalObject, callFrame);

    if (UNLIKELY(!ptr)) {
        return JSValue::encode(JSC::jsUndefined());
    }

    JSSHA256* instance = JSSHA256::create(vm, globalObject, structure, ptr);

    return JSValue::encode(instance);
}

extern "C" EncodedJSValue SHA256__create(Zig::GlobalObject* globalObject, void* ptr)
{
    auto& vm = globalObject->vm();
    JSC::Structure* structure = globalObject->JSSHA256Structure();
    JSSHA256* instance = JSSHA256::create(vm, globalObject, structure, ptr);
    return JSValue::encode(instance);
}

void JSSHA256Constructor::initializeProperties(VM& vm, JSC::JSGlobalObject* globalObject, JSSHA256Prototype* prototype)
{
}

const ClassInfo JSSHA256Constructor::s_info = { "Function"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSSHA256Constructor) };

extern "C" EncodedJSValue SHA256__getConstructor(Zig::GlobalObject* globalObject)
{
    return JSValue::encode(globalObject->JSSHA256Constructor());
}

JSSHA256::~JSSHA256()
{
    if (m_ctx) {
        SHA256Class__finalize(m_ctx);
    }
}
void JSSHA256::destroy(JSCell* cell)
{
    static_cast<JSSHA256*>(cell)->JSSHA256::~JSSHA256();
}

const ClassInfo JSSHA256::s_info = { "SHA256"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSSHA256) };

void JSSHA256::finishCreation(VM& vm)
{
    Base::finishCreation(vm);
    ASSERT(inherits(info()));
}

JSSHA256* JSSHA256::create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* ctx)
{
    JSSHA256* ptr = new (NotNull, JSC::allocateCell<JSSHA256>(vm)) JSSHA256(vm, structure, ctx);
    ptr->finishCreation(vm);
    return ptr;
}

extern "C" void* SHA256__fromJS(JSC::EncodedJSValue value)
{
    JSSHA256* object = JSC::jsDynamicCast<JSSHA256*>(JSValue::decode(value));
    if (!object)
        return nullptr;

    return object->wrapped();
}

extern "C" bool SHA256__dangerouslySetPtr(JSC::EncodedJSValue value, void* ptr)
{
    JSSHA256* object = JSC::jsDynamicCast<JSSHA256*>(JSValue::decode(value));
    if (!object)
        return false;

    object->m_ctx = ptr;
    return true;
}

extern "C" const size_t SHA256__ptrOffset = JSSHA256::offsetOfWrapped();

void JSSHA256::analyzeHeap(JSCell* cell, HeapAnalyzer& analyzer)
{
    auto* thisObject = jsCast<JSSHA256*>(cell);
    if (void* wrapped = thisObject->wrapped()) {
        // if (thisObject->scriptExecutionContext())
        //     analyzer.setLabelForCell(cell, "url " + thisObject->scriptExecutionContext()->url().string());
    }
    Base::analyzeHeap(cell, analyzer);
}

JSObject* JSSHA256::createPrototype(VM& vm, JSDOMGlobalObject* globalObject)
{
    return JSSHA256Prototype::create(vm, globalObject, JSSHA256Prototype::createStructure(vm, globalObject, globalObject->objectPrototype()));
}
extern "C" void* SHA512_256Class__construct(JSC::JSGlobalObject*, JSC::CallFrame*);
JSC_DECLARE_CUSTOM_GETTER(jsSHA512_256Constructor);
extern "C" void SHA512_256Class__finalize(void*);

extern "C" JSC::EncodedJSValue SHA512_256Prototype__getByteLength(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(SHA512_256Prototype__byteLengthGetterWrap);

extern "C" EncodedJSValue SHA512_256Prototype__digest(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(SHA512_256Prototype__digestCallback);

extern "C" EncodedJSValue SHA512_256Prototype__update(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(SHA512_256Prototype__updateCallback);

STATIC_ASSERT_ISO_SUBSPACE_SHARABLE(JSSHA512_256Prototype, JSSHA512_256Prototype::Base);

static const HashTableValue JSSHA512_256PrototypeTableValues[] = {
    { "byteLength"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute), NoIntrinsic, { (intptr_t) static_cast<PropertySlot::GetValueFunc>(SHA512_256Prototype__byteLengthGetterWrap), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "digest"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { (intptr_t) static_cast<RawNativeFunction>(SHA512_256Prototype__digestCallback), (intptr_t)(0) } },
    { "update"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { (intptr_t) static_cast<RawNativeFunction>(SHA512_256Prototype__updateCallback), (intptr_t)(0) } }
};

const ClassInfo JSSHA512_256Prototype::s_info = { "SHA512_256"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSSHA512_256Prototype) };

JSC_DEFINE_CUSTOM_GETTER(jsSHA512_256Constructor, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName))
{
    VM& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    auto* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto* prototype = jsDynamicCast<JSSHA512_256Prototype*>(JSValue::decode(thisValue));

    if (UNLIKELY(!prototype))
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    return JSValue::encode(globalObject->JSSHA512_256Constructor());
}

JSC_DEFINE_CUSTOM_GETTER(SHA512_256Prototype__byteLengthGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSSHA512_256* thisObject = jsCast<JSSHA512_256*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = SHA512_256Prototype__getByteLength(thisObject->wrapped(), globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_HOST_FUNCTION(SHA512_256Prototype__digestCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSSHA512_256* thisObject = jsDynamicCast<JSSHA512_256*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return SHA512_256Prototype__digest(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(SHA512_256Prototype__updateCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSSHA512_256* thisObject = jsDynamicCast<JSSHA512_256*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return SHA512_256Prototype__update(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

void JSSHA512_256Prototype::finishCreation(JSC::VM& vm, JSC::JSGlobalObject* globalObject)
{
    Base::finishCreation(vm);
    reifyStaticProperties(vm, JSSHA512_256::info(), JSSHA512_256PrototypeTableValues, *this);
    JSC_TO_STRING_TAG_WITHOUT_TRANSITION();
}

extern "C" JSC_DECLARE_CUSTOM_GETTER(SHA512_256Class__getByteLengthStatic);
extern "C" JSC_DECLARE_HOST_FUNCTION(SHA512_256Class__hash);

static const HashTableValue JSSHA512_256ConstructorTableValues[] = {
    { "byteLength"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute), NoIntrinsic, { (intptr_t) static_cast<PropertySlot::GetValueFunc>(SHA512_256Class__getByteLengthStatic), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "hash"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { (intptr_t) static_cast<RawNativeFunction>(SHA512_256Class__hash), (intptr_t)(2) } }
};

void JSSHA512_256Constructor::finishCreation(VM& vm, JSC::JSGlobalObject* globalObject, JSSHA512_256Prototype* prototype)
{
    Base::finishCreation(vm, 0, "SHA512_256"_s, PropertyAdditionMode::WithoutStructureTransition);
    reifyStaticProperties(vm, &JSSHA512_256Constructor::s_info, JSSHA512_256ConstructorTableValues, *this);
    ASSERT(inherits(info()));
}

JSSHA512_256Constructor* JSSHA512_256Constructor::create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, JSSHA512_256Prototype* prototype)
{
    JSSHA512_256Constructor* ptr = new (NotNull, JSC::allocateCell<JSSHA512_256Constructor>(vm)) JSSHA512_256Constructor(vm, structure, construct);
    ptr->finishCreation(vm, globalObject, prototype);
    return ptr;
}

JSC::EncodedJSValue JSC_HOST_CALL_ATTRIBUTES JSSHA512_256Constructor::construct(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame)
{
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    JSC::VM& vm = globalObject->vm();
    JSObject* newTarget = asObject(callFrame->newTarget());
    auto* constructor = globalObject->JSSHA512_256Constructor();
    Structure* structure = globalObject->JSSHA512_256Structure();
    if (constructor != newTarget) {
        auto scope = DECLARE_THROW_SCOPE(vm);

        auto* functionGlobalObject = reinterpret_cast<Zig::GlobalObject*>(
            // ShadowRealm functions belong to a different global object.
            getFunctionRealm(globalObject, newTarget));
        RETURN_IF_EXCEPTION(scope, {});
        structure = InternalFunction::createSubclassStructure(
            globalObject,
            newTarget,
            functionGlobalObject->JSSHA512_256Structure());
    }

    void* ptr = SHA512_256Class__construct(globalObject, callFrame);

    if (UNLIKELY(!ptr)) {
        return JSValue::encode(JSC::jsUndefined());
    }

    JSSHA512_256* instance = JSSHA512_256::create(vm, globalObject, structure, ptr);

    return JSValue::encode(instance);
}

extern "C" EncodedJSValue SHA512_256__create(Zig::GlobalObject* globalObject, void* ptr)
{
    auto& vm = globalObject->vm();
    JSC::Structure* structure = globalObject->JSSHA512_256Structure();
    JSSHA512_256* instance = JSSHA512_256::create(vm, globalObject, structure, ptr);
    return JSValue::encode(instance);
}

void JSSHA512_256Constructor::initializeProperties(VM& vm, JSC::JSGlobalObject* globalObject, JSSHA512_256Prototype* prototype)
{
}

const ClassInfo JSSHA512_256Constructor::s_info = { "Function"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSSHA512_256Constructor) };

extern "C" EncodedJSValue SHA512_256__getConstructor(Zig::GlobalObject* globalObject)
{
    return JSValue::encode(globalObject->JSSHA512_256Constructor());
}

JSSHA512_256::~JSSHA512_256()
{
    if (m_ctx) {
        SHA512_256Class__finalize(m_ctx);
    }
}
void JSSHA512_256::destroy(JSCell* cell)
{
    static_cast<JSSHA512_256*>(cell)->JSSHA512_256::~JSSHA512_256();
}

const ClassInfo JSSHA512_256::s_info = { "SHA512_256"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSSHA512_256) };

void JSSHA512_256::finishCreation(VM& vm)
{
    Base::finishCreation(vm);
    ASSERT(inherits(info()));
}

JSSHA512_256* JSSHA512_256::create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* ctx)
{
    JSSHA512_256* ptr = new (NotNull, JSC::allocateCell<JSSHA512_256>(vm)) JSSHA512_256(vm, structure, ctx);
    ptr->finishCreation(vm);
    return ptr;
}

extern "C" void* SHA512_256__fromJS(JSC::EncodedJSValue value)
{
    JSSHA512_256* object = JSC::jsDynamicCast<JSSHA512_256*>(JSValue::decode(value));
    if (!object)
        return nullptr;

    return object->wrapped();
}

extern "C" bool SHA512_256__dangerouslySetPtr(JSC::EncodedJSValue value, void* ptr)
{
    JSSHA512_256* object = JSC::jsDynamicCast<JSSHA512_256*>(JSValue::decode(value));
    if (!object)
        return false;

    object->m_ctx = ptr;
    return true;
}

extern "C" const size_t SHA512_256__ptrOffset = JSSHA512_256::offsetOfWrapped();

void JSSHA512_256::analyzeHeap(JSCell* cell, HeapAnalyzer& analyzer)
{
    auto* thisObject = jsCast<JSSHA512_256*>(cell);
    if (void* wrapped = thisObject->wrapped()) {
        // if (thisObject->scriptExecutionContext())
        //     analyzer.setLabelForCell(cell, "url " + thisObject->scriptExecutionContext()->url().string());
    }
    Base::analyzeHeap(cell, analyzer);
}

JSObject* JSSHA512_256::createPrototype(VM& vm, JSDOMGlobalObject* globalObject)
{
    return JSSHA512_256Prototype::create(vm, globalObject, JSSHA512_256Prototype::createStructure(vm, globalObject, globalObject->objectPrototype()));
}
extern "C" void* MD5_SHA1Class__construct(JSC::JSGlobalObject*, JSC::CallFrame*);
JSC_DECLARE_CUSTOM_GETTER(jsMD5_SHA1Constructor);
extern "C" void MD5_SHA1Class__finalize(void*);

extern "C" JSC::EncodedJSValue MD5_SHA1Prototype__getByteLength(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(MD5_SHA1Prototype__byteLengthGetterWrap);

extern "C" EncodedJSValue MD5_SHA1Prototype__digest(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(MD5_SHA1Prototype__digestCallback);

extern "C" EncodedJSValue MD5_SHA1Prototype__update(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(MD5_SHA1Prototype__updateCallback);

STATIC_ASSERT_ISO_SUBSPACE_SHARABLE(JSMD5_SHA1Prototype, JSMD5_SHA1Prototype::Base);

static const HashTableValue JSMD5_SHA1PrototypeTableValues[] = {
    { "byteLength"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute), NoIntrinsic, { (intptr_t) static_cast<PropertySlot::GetValueFunc>(MD5_SHA1Prototype__byteLengthGetterWrap), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "digest"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { (intptr_t) static_cast<RawNativeFunction>(MD5_SHA1Prototype__digestCallback), (intptr_t)(0) } },
    { "update"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { (intptr_t) static_cast<RawNativeFunction>(MD5_SHA1Prototype__updateCallback), (intptr_t)(0) } }
};

const ClassInfo JSMD5_SHA1Prototype::s_info = { "MD5_SHA1"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSMD5_SHA1Prototype) };

JSC_DEFINE_CUSTOM_GETTER(jsMD5_SHA1Constructor, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName))
{
    VM& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    auto* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto* prototype = jsDynamicCast<JSMD5_SHA1Prototype*>(JSValue::decode(thisValue));

    if (UNLIKELY(!prototype))
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    return JSValue::encode(globalObject->JSMD5_SHA1Constructor());
}

JSC_DEFINE_CUSTOM_GETTER(MD5_SHA1Prototype__byteLengthGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSMD5_SHA1* thisObject = jsCast<JSMD5_SHA1*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = MD5_SHA1Prototype__getByteLength(thisObject->wrapped(), globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_HOST_FUNCTION(MD5_SHA1Prototype__digestCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSMD5_SHA1* thisObject = jsDynamicCast<JSMD5_SHA1*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return MD5_SHA1Prototype__digest(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(MD5_SHA1Prototype__updateCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSMD5_SHA1* thisObject = jsDynamicCast<JSMD5_SHA1*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return MD5_SHA1Prototype__update(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

void JSMD5_SHA1Prototype::finishCreation(JSC::VM& vm, JSC::JSGlobalObject* globalObject)
{
    Base::finishCreation(vm);
    reifyStaticProperties(vm, JSMD5_SHA1::info(), JSMD5_SHA1PrototypeTableValues, *this);
    JSC_TO_STRING_TAG_WITHOUT_TRANSITION();
}

extern "C" JSC_DECLARE_CUSTOM_GETTER(MD5_SHA1Class__getByteLengthStatic);
extern "C" JSC_DECLARE_HOST_FUNCTION(MD5_SHA1Class__hash);

static const HashTableValue JSMD5_SHA1ConstructorTableValues[] = {
    { "byteLength"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute), NoIntrinsic, { (intptr_t) static_cast<PropertySlot::GetValueFunc>(MD5_SHA1Class__getByteLengthStatic), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "hash"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { (intptr_t) static_cast<RawNativeFunction>(MD5_SHA1Class__hash), (intptr_t)(2) } }
};

void JSMD5_SHA1Constructor::finishCreation(VM& vm, JSC::JSGlobalObject* globalObject, JSMD5_SHA1Prototype* prototype)
{
    Base::finishCreation(vm, 0, "MD5_SHA1"_s, PropertyAdditionMode::WithoutStructureTransition);
    reifyStaticProperties(vm, &JSMD5_SHA1Constructor::s_info, JSMD5_SHA1ConstructorTableValues, *this);
    ASSERT(inherits(info()));
}

JSMD5_SHA1Constructor* JSMD5_SHA1Constructor::create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, JSMD5_SHA1Prototype* prototype)
{
    JSMD5_SHA1Constructor* ptr = new (NotNull, JSC::allocateCell<JSMD5_SHA1Constructor>(vm)) JSMD5_SHA1Constructor(vm, structure, construct);
    ptr->finishCreation(vm, globalObject, prototype);
    return ptr;
}

JSC::EncodedJSValue JSC_HOST_CALL_ATTRIBUTES JSMD5_SHA1Constructor::construct(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame)
{
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    JSC::VM& vm = globalObject->vm();
    JSObject* newTarget = asObject(callFrame->newTarget());
    auto* constructor = globalObject->JSMD5_SHA1Constructor();
    Structure* structure = globalObject->JSMD5_SHA1Structure();
    if (constructor != newTarget) {
        auto scope = DECLARE_THROW_SCOPE(vm);

        auto* functionGlobalObject = reinterpret_cast<Zig::GlobalObject*>(
            // ShadowRealm functions belong to a different global object.
            getFunctionRealm(globalObject, newTarget));
        RETURN_IF_EXCEPTION(scope, {});
        structure = InternalFunction::createSubclassStructure(
            globalObject,
            newTarget,
            functionGlobalObject->JSMD5_SHA1Structure());
    }

    void* ptr = MD5_SHA1Class__construct(globalObject, callFrame);

    if (UNLIKELY(!ptr)) {
        return JSValue::encode(JSC::jsUndefined());
    }

    JSMD5_SHA1* instance = JSMD5_SHA1::create(vm, globalObject, structure, ptr);

    return JSValue::encode(instance);
}

extern "C" EncodedJSValue MD5_SHA1__create(Zig::GlobalObject* globalObject, void* ptr)
{
    auto& vm = globalObject->vm();
    JSC::Structure* structure = globalObject->JSMD5_SHA1Structure();
    JSMD5_SHA1* instance = JSMD5_SHA1::create(vm, globalObject, structure, ptr);
    return JSValue::encode(instance);
}

void JSMD5_SHA1Constructor::initializeProperties(VM& vm, JSC::JSGlobalObject* globalObject, JSMD5_SHA1Prototype* prototype)
{
}

const ClassInfo JSMD5_SHA1Constructor::s_info = { "Function"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSMD5_SHA1Constructor) };

extern "C" EncodedJSValue MD5_SHA1__getConstructor(Zig::GlobalObject* globalObject)
{
    return JSValue::encode(globalObject->JSMD5_SHA1Constructor());
}

JSMD5_SHA1::~JSMD5_SHA1()
{
    if (m_ctx) {
        MD5_SHA1Class__finalize(m_ctx);
    }
}
void JSMD5_SHA1::destroy(JSCell* cell)
{
    static_cast<JSMD5_SHA1*>(cell)->JSMD5_SHA1::~JSMD5_SHA1();
}

const ClassInfo JSMD5_SHA1::s_info = { "MD5_SHA1"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSMD5_SHA1) };

void JSMD5_SHA1::finishCreation(VM& vm)
{
    Base::finishCreation(vm);
    ASSERT(inherits(info()));
}

JSMD5_SHA1* JSMD5_SHA1::create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* ctx)
{
    JSMD5_SHA1* ptr = new (NotNull, JSC::allocateCell<JSMD5_SHA1>(vm)) JSMD5_SHA1(vm, structure, ctx);
    ptr->finishCreation(vm);
    return ptr;
}

extern "C" void* MD5_SHA1__fromJS(JSC::EncodedJSValue value)
{
    JSMD5_SHA1* object = JSC::jsDynamicCast<JSMD5_SHA1*>(JSValue::decode(value));
    if (!object)
        return nullptr;

    return object->wrapped();
}

extern "C" bool MD5_SHA1__dangerouslySetPtr(JSC::EncodedJSValue value, void* ptr)
{
    JSMD5_SHA1* object = JSC::jsDynamicCast<JSMD5_SHA1*>(JSValue::decode(value));
    if (!object)
        return false;

    object->m_ctx = ptr;
    return true;
}

extern "C" const size_t MD5_SHA1__ptrOffset = JSMD5_SHA1::offsetOfWrapped();

void JSMD5_SHA1::analyzeHeap(JSCell* cell, HeapAnalyzer& analyzer)
{
    auto* thisObject = jsCast<JSMD5_SHA1*>(cell);
    if (void* wrapped = thisObject->wrapped()) {
        // if (thisObject->scriptExecutionContext())
        //     analyzer.setLabelForCell(cell, "url " + thisObject->scriptExecutionContext()->url().string());
    }
    Base::analyzeHeap(cell, analyzer);
}

JSObject* JSMD5_SHA1::createPrototype(VM& vm, JSDOMGlobalObject* globalObject)
{
    return JSMD5_SHA1Prototype::create(vm, globalObject, JSMD5_SHA1Prototype::createStructure(vm, globalObject, globalObject->objectPrototype()));
}
extern "C" void* RequestClass__construct(JSC::JSGlobalObject*, JSC::CallFrame*);
JSC_DECLARE_CUSTOM_GETTER(jsRequestConstructor);
extern "C" void RequestClass__finalize(void*);

extern "C" EncodedJSValue RequestPrototype__getArrayBuffer(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(RequestPrototype__arrayBufferCallback);

extern "C" EncodedJSValue RequestPrototype__getBlob(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(RequestPrototype__blobCallback);

extern "C" JSC::EncodedJSValue RequestPrototype__getBodyUsed(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(RequestPrototype__bodyUsedGetterWrap);

extern "C" JSC::EncodedJSValue RequestPrototype__getCache(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(RequestPrototype__cacheGetterWrap);

extern "C" EncodedJSValue RequestPrototype__doClone(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(RequestPrototype__cloneCallback);

extern "C" JSC::EncodedJSValue RequestPrototype__getCredentials(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(RequestPrototype__credentialsGetterWrap);

extern "C" JSC::EncodedJSValue RequestPrototype__getDestination(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(RequestPrototype__destinationGetterWrap);

extern "C" JSC::EncodedJSValue RequestPrototype__getHeaders(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(RequestPrototype__headersGetterWrap);

extern "C" JSC::EncodedJSValue RequestPrototype__getIntegrity(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(RequestPrototype__integrityGetterWrap);

extern "C" EncodedJSValue RequestPrototype__getJSON(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(RequestPrototype__jsonCallback);

extern "C" JSC::EncodedJSValue RequestPrototype__getMethod(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(RequestPrototype__methodGetterWrap);

extern "C" JSC::EncodedJSValue RequestPrototype__getMode(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(RequestPrototype__modeGetterWrap);

extern "C" JSC::EncodedJSValue RequestPrototype__getRedirect(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(RequestPrototype__redirectGetterWrap);

extern "C" JSC::EncodedJSValue RequestPrototype__getReferrer(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(RequestPrototype__referrerGetterWrap);

extern "C" JSC::EncodedJSValue RequestPrototype__getReferrerPolicy(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(RequestPrototype__referrerPolicyGetterWrap);

extern "C" EncodedJSValue RequestPrototype__getText(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(RequestPrototype__textCallback);

extern "C" JSC::EncodedJSValue RequestPrototype__getUrl(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(RequestPrototype__urlGetterWrap);

STATIC_ASSERT_ISO_SUBSPACE_SHARABLE(JSRequestPrototype, JSRequestPrototype::Base);

static const HashTableValue JSRequestPrototypeTableValues[] = {
    { "arrayBuffer"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { (intptr_t) static_cast<RawNativeFunction>(RequestPrototype__arrayBufferCallback), (intptr_t)(0) } },
    { "blob"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { (intptr_t) static_cast<RawNativeFunction>(RequestPrototype__blobCallback), (intptr_t)(0) } },
    { "bodyUsed"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute), NoIntrinsic, { (intptr_t) static_cast<PropertySlot::GetValueFunc>(RequestPrototype__bodyUsedGetterWrap), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "cache"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute), NoIntrinsic, { (intptr_t) static_cast<PropertySlot::GetValueFunc>(RequestPrototype__cacheGetterWrap), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "clone"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { (intptr_t) static_cast<RawNativeFunction>(RequestPrototype__cloneCallback), (intptr_t)(1) } },
    { "credentials"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute), NoIntrinsic, { (intptr_t) static_cast<PropertySlot::GetValueFunc>(RequestPrototype__credentialsGetterWrap), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "destination"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute), NoIntrinsic, { (intptr_t) static_cast<PropertySlot::GetValueFunc>(RequestPrototype__destinationGetterWrap), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "headers"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute), NoIntrinsic, { (intptr_t) static_cast<PropertySlot::GetValueFunc>(RequestPrototype__headersGetterWrap), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "integrity"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute), NoIntrinsic, { (intptr_t) static_cast<PropertySlot::GetValueFunc>(RequestPrototype__integrityGetterWrap), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "json"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { (intptr_t) static_cast<RawNativeFunction>(RequestPrototype__jsonCallback), (intptr_t)(0) } },
    { "method"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute), NoIntrinsic, { (intptr_t) static_cast<PropertySlot::GetValueFunc>(RequestPrototype__methodGetterWrap), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "mode"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute), NoIntrinsic, { (intptr_t) static_cast<PropertySlot::GetValueFunc>(RequestPrototype__modeGetterWrap), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "redirect"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute), NoIntrinsic, { (intptr_t) static_cast<PropertySlot::GetValueFunc>(RequestPrototype__redirectGetterWrap), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "referrer"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute), NoIntrinsic, { (intptr_t) static_cast<PropertySlot::GetValueFunc>(RequestPrototype__referrerGetterWrap), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "referrerPolicy"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute), NoIntrinsic, { (intptr_t) static_cast<PropertySlot::GetValueFunc>(RequestPrototype__referrerPolicyGetterWrap), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "text"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { (intptr_t) static_cast<RawNativeFunction>(RequestPrototype__textCallback), (intptr_t)(0) } },
    { "url"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute), NoIntrinsic, { (intptr_t) static_cast<PropertySlot::GetValueFunc>(RequestPrototype__urlGetterWrap), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } }
};

const ClassInfo JSRequestPrototype::s_info = { "Request"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSRequestPrototype) };

JSC_DEFINE_CUSTOM_GETTER(jsRequestConstructor, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName))
{
    VM& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    auto* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto* prototype = jsDynamicCast<JSRequestPrototype*>(JSValue::decode(thisValue));

    if (UNLIKELY(!prototype))
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    return JSValue::encode(globalObject->JSRequestConstructor());
}

JSC_DEFINE_HOST_FUNCTION(RequestPrototype__arrayBufferCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSRequest* thisObject = jsDynamicCast<JSRequest*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return RequestPrototype__getArrayBuffer(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(RequestPrototype__blobCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSRequest* thisObject = jsDynamicCast<JSRequest*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return RequestPrototype__getBlob(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_CUSTOM_GETTER(RequestPrototype__bodyUsedGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSRequest* thisObject = jsCast<JSRequest*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = RequestPrototype__getBodyUsed(thisObject->wrapped(), globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_CUSTOM_GETTER(RequestPrototype__cacheGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSRequest* thisObject = jsCast<JSRequest*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = RequestPrototype__getCache(thisObject->wrapped(), globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_HOST_FUNCTION(RequestPrototype__cloneCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSRequest* thisObject = jsDynamicCast<JSRequest*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return RequestPrototype__doClone(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_CUSTOM_GETTER(RequestPrototype__credentialsGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSRequest* thisObject = jsCast<JSRequest*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = RequestPrototype__getCredentials(thisObject->wrapped(), globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_CUSTOM_GETTER(RequestPrototype__destinationGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSRequest* thisObject = jsCast<JSRequest*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = RequestPrototype__getDestination(thisObject->wrapped(), globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_CUSTOM_GETTER(RequestPrototype__headersGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSRequest* thisObject = jsCast<JSRequest*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    if (JSValue cachedValue = thisObject->m_headers.get())
        return JSValue::encode(cachedValue);

    JSC::JSValue result = JSC::JSValue::decode(
        RequestPrototype__getHeaders(thisObject->wrapped(), globalObject));
    RETURN_IF_EXCEPTION(throwScope, {});
    thisObject->m_headers.set(vm, thisObject, result);
    RELEASE_AND_RETURN(throwScope, JSValue::encode(result));
}

JSC_DEFINE_CUSTOM_GETTER(RequestPrototype__integrityGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSRequest* thisObject = jsCast<JSRequest*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = RequestPrototype__getIntegrity(thisObject->wrapped(), globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_HOST_FUNCTION(RequestPrototype__jsonCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSRequest* thisObject = jsDynamicCast<JSRequest*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return RequestPrototype__getJSON(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_CUSTOM_GETTER(RequestPrototype__methodGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSRequest* thisObject = jsCast<JSRequest*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = RequestPrototype__getMethod(thisObject->wrapped(), globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_CUSTOM_GETTER(RequestPrototype__modeGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSRequest* thisObject = jsCast<JSRequest*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = RequestPrototype__getMode(thisObject->wrapped(), globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_CUSTOM_GETTER(RequestPrototype__redirectGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSRequest* thisObject = jsCast<JSRequest*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = RequestPrototype__getRedirect(thisObject->wrapped(), globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_CUSTOM_GETTER(RequestPrototype__referrerGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSRequest* thisObject = jsCast<JSRequest*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = RequestPrototype__getReferrer(thisObject->wrapped(), globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_CUSTOM_GETTER(RequestPrototype__referrerPolicyGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSRequest* thisObject = jsCast<JSRequest*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = RequestPrototype__getReferrerPolicy(thisObject->wrapped(), globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_HOST_FUNCTION(RequestPrototype__textCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSRequest* thisObject = jsDynamicCast<JSRequest*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return RequestPrototype__getText(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_CUSTOM_GETTER(RequestPrototype__urlGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSRequest* thisObject = jsCast<JSRequest*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    if (JSValue cachedValue = thisObject->m_url.get())
        return JSValue::encode(cachedValue);

    JSC::JSValue result = JSC::JSValue::decode(
        RequestPrototype__getUrl(thisObject->wrapped(), globalObject));
    RETURN_IF_EXCEPTION(throwScope, {});
    thisObject->m_url.set(vm, thisObject, result);
    RELEASE_AND_RETURN(throwScope, JSValue::encode(result));
}

void JSRequestPrototype::finishCreation(JSC::VM& vm, JSC::JSGlobalObject* globalObject)
{
    Base::finishCreation(vm);
    reifyStaticProperties(vm, JSRequest::info(), JSRequestPrototypeTableValues, *this);
    JSC_TO_STRING_TAG_WITHOUT_TRANSITION();
}

void JSRequestConstructor::finishCreation(VM& vm, JSC::JSGlobalObject* globalObject, JSRequestPrototype* prototype)
{
    Base::finishCreation(vm, 0, "Request"_s, PropertyAdditionMode::WithoutStructureTransition);

    ASSERT(inherits(info()));
}

JSRequestConstructor* JSRequestConstructor::create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, JSRequestPrototype* prototype)
{
    JSRequestConstructor* ptr = new (NotNull, JSC::allocateCell<JSRequestConstructor>(vm)) JSRequestConstructor(vm, structure, construct);
    ptr->finishCreation(vm, globalObject, prototype);
    return ptr;
}

JSC::EncodedJSValue JSC_HOST_CALL_ATTRIBUTES JSRequestConstructor::construct(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame)
{
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    JSC::VM& vm = globalObject->vm();
    JSObject* newTarget = asObject(callFrame->newTarget());
    auto* constructor = globalObject->JSRequestConstructor();
    Structure* structure = globalObject->JSRequestStructure();
    if (constructor != newTarget) {
        auto scope = DECLARE_THROW_SCOPE(vm);

        auto* functionGlobalObject = reinterpret_cast<Zig::GlobalObject*>(
            // ShadowRealm functions belong to a different global object.
            getFunctionRealm(globalObject, newTarget));
        RETURN_IF_EXCEPTION(scope, {});
        structure = InternalFunction::createSubclassStructure(
            globalObject,
            newTarget,
            functionGlobalObject->JSRequestStructure());
    }

    void* ptr = RequestClass__construct(globalObject, callFrame);

    if (UNLIKELY(!ptr)) {
        return JSValue::encode(JSC::jsUndefined());
    }

    JSRequest* instance = JSRequest::create(vm, globalObject, structure, ptr);

    return JSValue::encode(instance);
}

extern "C" EncodedJSValue Request__create(Zig::GlobalObject* globalObject, void* ptr)
{
    auto& vm = globalObject->vm();
    JSC::Structure* structure = globalObject->JSRequestStructure();
    JSRequest* instance = JSRequest::create(vm, globalObject, structure, ptr);
    return JSValue::encode(instance);
}

void JSRequestConstructor::initializeProperties(VM& vm, JSC::JSGlobalObject* globalObject, JSRequestPrototype* prototype)
{
}

const ClassInfo JSRequestConstructor::s_info = { "Function"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSRequestConstructor) };

extern "C" EncodedJSValue Request__getConstructor(Zig::GlobalObject* globalObject)
{
    return JSValue::encode(globalObject->JSRequestConstructor());
}

JSRequest::~JSRequest()
{
    if (m_ctx) {
        RequestClass__finalize(m_ctx);
    }
}
void JSRequest::destroy(JSCell* cell)
{
    static_cast<JSRequest*>(cell)->JSRequest::~JSRequest();
}

const ClassInfo JSRequest::s_info = { "Request"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSRequest) };

void JSRequest::finishCreation(VM& vm)
{
    Base::finishCreation(vm);
    ASSERT(inherits(info()));
}

JSRequest* JSRequest::create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* ctx)
{
    JSRequest* ptr = new (NotNull, JSC::allocateCell<JSRequest>(vm)) JSRequest(vm, structure, ctx);
    ptr->finishCreation(vm);
    return ptr;
}

extern "C" void* Request__fromJS(JSC::EncodedJSValue value)
{
    JSRequest* object = JSC::jsDynamicCast<JSRequest*>(JSValue::decode(value));
    if (!object)
        return nullptr;

    return object->wrapped();
}

extern "C" bool Request__dangerouslySetPtr(JSC::EncodedJSValue value, void* ptr)
{
    JSRequest* object = JSC::jsDynamicCast<JSRequest*>(JSValue::decode(value));
    if (!object)
        return false;

    object->m_ctx = ptr;
    return true;
}

extern "C" const size_t Request__ptrOffset = JSRequest::offsetOfWrapped();

void JSRequest::analyzeHeap(JSCell* cell, HeapAnalyzer& analyzer)
{
    auto* thisObject = jsCast<JSRequest*>(cell);
    if (void* wrapped = thisObject->wrapped()) {
        // if (thisObject->scriptExecutionContext())
        //     analyzer.setLabelForCell(cell, "url " + thisObject->scriptExecutionContext()->url().string());
    }
    Base::analyzeHeap(cell, analyzer);
}

JSObject* JSRequest::createPrototype(VM& vm, JSDOMGlobalObject* globalObject)
{
    return JSRequestPrototype::create(vm, globalObject, JSRequestPrototype::createStructure(vm, globalObject, globalObject->objectPrototype()));
}

template<typename Visitor>
void JSRequest::visitChildrenImpl(JSCell* cell, Visitor& visitor)
{
    JSRequest* thisObject = jsCast<JSRequest*>(cell);
    ASSERT_GC_OBJECT_INHERITS(thisObject, info());
    Base::visitChildren(thisObject, visitor);
    visitor.append(thisObject->m_headers);
    visitor.append(thisObject->m_url);
}

DEFINE_VISIT_CHILDREN(JSRequest);
extern "C" void* ResponseClass__construct(JSC::JSGlobalObject*, JSC::CallFrame*);
JSC_DECLARE_CUSTOM_GETTER(jsResponseConstructor);
extern "C" void ResponseClass__finalize(void*);

extern "C" EncodedJSValue ResponsePrototype__getArrayBuffer(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(ResponsePrototype__arrayBufferCallback);

extern "C" EncodedJSValue ResponsePrototype__getBlob(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(ResponsePrototype__blobCallback);

extern "C" JSC::EncodedJSValue ResponsePrototype__getBodyUsed(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(ResponsePrototype__bodyUsedGetterWrap);

extern "C" EncodedJSValue ResponsePrototype__doClone(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(ResponsePrototype__cloneCallback);

extern "C" JSC::EncodedJSValue ResponsePrototype__getHeaders(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(ResponsePrototype__headersGetterWrap);

extern "C" EncodedJSValue ResponsePrototype__getJSON(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(ResponsePrototype__jsonCallback);

extern "C" JSC::EncodedJSValue ResponsePrototype__getOK(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(ResponsePrototype__okGetterWrap);

extern "C" JSC::EncodedJSValue ResponsePrototype__getStatus(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(ResponsePrototype__statusGetterWrap);

extern "C" JSC::EncodedJSValue ResponsePrototype__getStatusText(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(ResponsePrototype__statusTextGetterWrap);

extern "C" EncodedJSValue ResponsePrototype__getText(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(ResponsePrototype__textCallback);

extern "C" JSC::EncodedJSValue ResponsePrototype__getResponseType(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(ResponsePrototype__typeGetterWrap);

extern "C" JSC::EncodedJSValue ResponsePrototype__getURL(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(ResponsePrototype__urlGetterWrap);

STATIC_ASSERT_ISO_SUBSPACE_SHARABLE(JSResponsePrototype, JSResponsePrototype::Base);

static const HashTableValue JSResponsePrototypeTableValues[] = {
    { "arrayBuffer"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { (intptr_t) static_cast<RawNativeFunction>(ResponsePrototype__arrayBufferCallback), (intptr_t)(0) } },
    { "blob"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { (intptr_t) static_cast<RawNativeFunction>(ResponsePrototype__blobCallback), (intptr_t)(0) } },
    { "bodyUsed"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute), NoIntrinsic, { (intptr_t) static_cast<PropertySlot::GetValueFunc>(ResponsePrototype__bodyUsedGetterWrap), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "clone"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { (intptr_t) static_cast<RawNativeFunction>(ResponsePrototype__cloneCallback), (intptr_t)(1) } },
    { "headers"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute), NoIntrinsic, { (intptr_t) static_cast<PropertySlot::GetValueFunc>(ResponsePrototype__headersGetterWrap), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "json"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { (intptr_t) static_cast<RawNativeFunction>(ResponsePrototype__jsonCallback), (intptr_t)(0) } },
    { "ok"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute), NoIntrinsic, { (intptr_t) static_cast<PropertySlot::GetValueFunc>(ResponsePrototype__okGetterWrap), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "status"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute), NoIntrinsic, { (intptr_t) static_cast<PropertySlot::GetValueFunc>(ResponsePrototype__statusGetterWrap), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "statusText"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute), NoIntrinsic, { (intptr_t) static_cast<PropertySlot::GetValueFunc>(ResponsePrototype__statusTextGetterWrap), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "text"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { (intptr_t) static_cast<RawNativeFunction>(ResponsePrototype__textCallback), (intptr_t)(0) } },
    { "type"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute), NoIntrinsic, { (intptr_t) static_cast<PropertySlot::GetValueFunc>(ResponsePrototype__typeGetterWrap), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "url"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute), NoIntrinsic, { (intptr_t) static_cast<PropertySlot::GetValueFunc>(ResponsePrototype__urlGetterWrap), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } }
};

const ClassInfo JSResponsePrototype::s_info = { "Response"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSResponsePrototype) };

JSC_DEFINE_CUSTOM_GETTER(jsResponseConstructor, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName))
{
    VM& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    auto* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto* prototype = jsDynamicCast<JSResponsePrototype*>(JSValue::decode(thisValue));

    if (UNLIKELY(!prototype))
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    return JSValue::encode(globalObject->JSResponseConstructor());
}

JSC_DEFINE_HOST_FUNCTION(ResponsePrototype__arrayBufferCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSResponse* thisObject = jsDynamicCast<JSResponse*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return ResponsePrototype__getArrayBuffer(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(ResponsePrototype__blobCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSResponse* thisObject = jsDynamicCast<JSResponse*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return ResponsePrototype__getBlob(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_CUSTOM_GETTER(ResponsePrototype__bodyUsedGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSResponse* thisObject = jsCast<JSResponse*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = ResponsePrototype__getBodyUsed(thisObject->wrapped(), globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_HOST_FUNCTION(ResponsePrototype__cloneCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSResponse* thisObject = jsDynamicCast<JSResponse*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return ResponsePrototype__doClone(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_CUSTOM_GETTER(ResponsePrototype__headersGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSResponse* thisObject = jsCast<JSResponse*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    if (JSValue cachedValue = thisObject->m_headers.get())
        return JSValue::encode(cachedValue);

    JSC::JSValue result = JSC::JSValue::decode(
        ResponsePrototype__getHeaders(thisObject->wrapped(), globalObject));
    RETURN_IF_EXCEPTION(throwScope, {});
    thisObject->m_headers.set(vm, thisObject, result);
    RELEASE_AND_RETURN(throwScope, JSValue::encode(result));
}

JSC_DEFINE_HOST_FUNCTION(ResponsePrototype__jsonCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSResponse* thisObject = jsDynamicCast<JSResponse*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return ResponsePrototype__getJSON(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_CUSTOM_GETTER(ResponsePrototype__okGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSResponse* thisObject = jsCast<JSResponse*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = ResponsePrototype__getOK(thisObject->wrapped(), globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_CUSTOM_GETTER(ResponsePrototype__statusGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSResponse* thisObject = jsCast<JSResponse*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = ResponsePrototype__getStatus(thisObject->wrapped(), globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_CUSTOM_GETTER(ResponsePrototype__statusTextGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSResponse* thisObject = jsCast<JSResponse*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    if (JSValue cachedValue = thisObject->m_statusText.get())
        return JSValue::encode(cachedValue);

    JSC::JSValue result = JSC::JSValue::decode(
        ResponsePrototype__getStatusText(thisObject->wrapped(), globalObject));
    RETURN_IF_EXCEPTION(throwScope, {});
    thisObject->m_statusText.set(vm, thisObject, result);
    RELEASE_AND_RETURN(throwScope, JSValue::encode(result));
}

JSC_DEFINE_HOST_FUNCTION(ResponsePrototype__textCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSResponse* thisObject = jsDynamicCast<JSResponse*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return ResponsePrototype__getText(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_CUSTOM_GETTER(ResponsePrototype__typeGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSResponse* thisObject = jsCast<JSResponse*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = ResponsePrototype__getResponseType(thisObject->wrapped(), globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_CUSTOM_GETTER(ResponsePrototype__urlGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSResponse* thisObject = jsCast<JSResponse*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    if (JSValue cachedValue = thisObject->m_url.get())
        return JSValue::encode(cachedValue);

    JSC::JSValue result = JSC::JSValue::decode(
        ResponsePrototype__getURL(thisObject->wrapped(), globalObject));
    RETURN_IF_EXCEPTION(throwScope, {});
    thisObject->m_url.set(vm, thisObject, result);
    RELEASE_AND_RETURN(throwScope, JSValue::encode(result));
}

void JSResponsePrototype::finishCreation(JSC::VM& vm, JSC::JSGlobalObject* globalObject)
{
    Base::finishCreation(vm);
    reifyStaticProperties(vm, JSResponse::info(), JSResponsePrototypeTableValues, *this);
    JSC_TO_STRING_TAG_WITHOUT_TRANSITION();
}

extern "C" JSC_DECLARE_HOST_FUNCTION(ResponseClass__constructError);
extern "C" JSC_DECLARE_HOST_FUNCTION(ResponseClass__constructJSON);
extern "C" JSC_DECLARE_HOST_FUNCTION(ResponseClass__constructRedirect);

static const HashTableValue JSResponseConstructorTableValues[] = {
    { "error"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { (intptr_t) static_cast<RawNativeFunction>(ResponseClass__constructError), (intptr_t)(0) } },
    { "json"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { (intptr_t) static_cast<RawNativeFunction>(ResponseClass__constructJSON), (intptr_t)(0) } },
    { "redirect"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { (intptr_t) static_cast<RawNativeFunction>(ResponseClass__constructRedirect), (intptr_t)(0) } }
};

void JSResponseConstructor::finishCreation(VM& vm, JSC::JSGlobalObject* globalObject, JSResponsePrototype* prototype)
{
    Base::finishCreation(vm, 0, "Response"_s, PropertyAdditionMode::WithoutStructureTransition);
    reifyStaticProperties(vm, &JSResponseConstructor::s_info, JSResponseConstructorTableValues, *this);
    ASSERT(inherits(info()));
}

JSResponseConstructor* JSResponseConstructor::create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, JSResponsePrototype* prototype)
{
    JSResponseConstructor* ptr = new (NotNull, JSC::allocateCell<JSResponseConstructor>(vm)) JSResponseConstructor(vm, structure, construct);
    ptr->finishCreation(vm, globalObject, prototype);
    return ptr;
}

JSC::EncodedJSValue JSC_HOST_CALL_ATTRIBUTES JSResponseConstructor::construct(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame)
{
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    JSC::VM& vm = globalObject->vm();
    JSObject* newTarget = asObject(callFrame->newTarget());
    auto* constructor = globalObject->JSResponseConstructor();
    Structure* structure = globalObject->JSResponseStructure();
    if (constructor != newTarget) {
        auto scope = DECLARE_THROW_SCOPE(vm);

        auto* functionGlobalObject = reinterpret_cast<Zig::GlobalObject*>(
            // ShadowRealm functions belong to a different global object.
            getFunctionRealm(globalObject, newTarget));
        RETURN_IF_EXCEPTION(scope, {});
        structure = InternalFunction::createSubclassStructure(
            globalObject,
            newTarget,
            functionGlobalObject->JSResponseStructure());
    }

    void* ptr = ResponseClass__construct(globalObject, callFrame);

    if (UNLIKELY(!ptr)) {
        return JSValue::encode(JSC::jsUndefined());
    }

    JSResponse* instance = JSResponse::create(vm, globalObject, structure, ptr);

    return JSValue::encode(instance);
}

extern "C" EncodedJSValue Response__create(Zig::GlobalObject* globalObject, void* ptr)
{
    auto& vm = globalObject->vm();
    JSC::Structure* structure = globalObject->JSResponseStructure();
    JSResponse* instance = JSResponse::create(vm, globalObject, structure, ptr);
    return JSValue::encode(instance);
}

void JSResponseConstructor::initializeProperties(VM& vm, JSC::JSGlobalObject* globalObject, JSResponsePrototype* prototype)
{
}

const ClassInfo JSResponseConstructor::s_info = { "Function"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSResponseConstructor) };

extern "C" EncodedJSValue Response__getConstructor(Zig::GlobalObject* globalObject)
{
    return JSValue::encode(globalObject->JSResponseConstructor());
}

JSResponse::~JSResponse()
{
    if (m_ctx) {
        ResponseClass__finalize(m_ctx);
    }
}
void JSResponse::destroy(JSCell* cell)
{
    static_cast<JSResponse*>(cell)->JSResponse::~JSResponse();
}

const ClassInfo JSResponse::s_info = { "Response"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSResponse) };

void JSResponse::finishCreation(VM& vm)
{
    Base::finishCreation(vm);
    ASSERT(inherits(info()));
}

JSResponse* JSResponse::create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* ctx)
{
    JSResponse* ptr = new (NotNull, JSC::allocateCell<JSResponse>(vm)) JSResponse(vm, structure, ctx);
    ptr->finishCreation(vm);
    return ptr;
}

extern "C" void* Response__fromJS(JSC::EncodedJSValue value)
{
    JSResponse* object = JSC::jsDynamicCast<JSResponse*>(JSValue::decode(value));
    if (!object)
        return nullptr;

    return object->wrapped();
}

extern "C" bool Response__dangerouslySetPtr(JSC::EncodedJSValue value, void* ptr)
{
    JSResponse* object = JSC::jsDynamicCast<JSResponse*>(JSValue::decode(value));
    if (!object)
        return false;

    object->m_ctx = ptr;
    return true;
}

extern "C" const size_t Response__ptrOffset = JSResponse::offsetOfWrapped();

void JSResponse::analyzeHeap(JSCell* cell, HeapAnalyzer& analyzer)
{
    auto* thisObject = jsCast<JSResponse*>(cell);
    if (void* wrapped = thisObject->wrapped()) {
        // if (thisObject->scriptExecutionContext())
        //     analyzer.setLabelForCell(cell, "url " + thisObject->scriptExecutionContext()->url().string());
    }
    Base::analyzeHeap(cell, analyzer);
}

JSObject* JSResponse::createPrototype(VM& vm, JSDOMGlobalObject* globalObject)
{
    return JSResponsePrototype::create(vm, globalObject, JSResponsePrototype::createStructure(vm, globalObject, globalObject->objectPrototype()));
}

template<typename Visitor>
void JSResponse::visitChildrenImpl(JSCell* cell, Visitor& visitor)
{
    JSResponse* thisObject = jsCast<JSResponse*>(cell);
    ASSERT_GC_OBJECT_INHERITS(thisObject, info());
    Base::visitChildren(thisObject, visitor);
    visitor.append(thisObject->m_headers);
    visitor.append(thisObject->m_statusText);
    visitor.append(thisObject->m_url);
}

DEFINE_VISIT_CHILDREN(JSResponse);

} // namespace WebCore
