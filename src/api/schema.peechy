package Api;

smol Loader {
    jsx = 1;
    js = 2;
    ts = 3;
    tsx = 4;
    css = 5;
    file = 6;
    json = 7;
}

smol ResolveMode {
  disable = 1;
  lazy = 2;
  dev = 3;
  bundle = 4;
}

smol Platform {
  browser = 1;
  node = 2;
}

smol JSXRuntime {
  automatic = 1;
  classic = 2;
}

struct JSX {
  string factory;
  JSXRuntime runtime;
  string fragment;
  bool development;

  // Probably react
  string import_source;

  bool react_fast_refresh;
}

struct StringPointer {
  uint32 offset;
  uint32 length;
}

struct JavascriptBundledModule {
  // package-relative path including file extension
  StringPointer path;

  // Source code
  StringPointer code;

  // index into JavascriptBundle.packages
  uint32 package_id;

  // The ESM export is this id ("$" + number.toString(16))
  uint32 id;

  // This lets us efficiently compare strings ignoring the extension
  byte path_extname_length;
}

struct JavascriptBundledPackage {
  StringPointer name;
  StringPointer version;
  uint32 hash;

  uint32 modules_offset;
  uint32 modules_length;
}

struct JavascriptBundle {
  // These are sorted alphabetically so you can do binary search
  JavascriptBundledModule[] modules;
  JavascriptBundledPackage[] packages;
  
  // This is ASCII-encoded so you can send it directly over HTTP
  byte[] etag;

  uint32 generated_at;
  
  // generated by hashing all ${name}@${version} in sorted order
  byte[] app_package_json_dependencies_hash;


  byte[] import_from_name;

  // This is what StringPointer refers to 
  byte[] manifest_string;
}

message JavascriptBundleContainer {
  uint32 bundle_format_version = 1;

  JavascriptBundle bundle = 2;

  // Don't technically need to store this, but it may be helpful as a sanity check
  uint32 code_length = 3;
}

smol ScanDependencyMode {
  app = 1;
  all = 2;
}

smol ModuleImportType {
  import = 1;
  require = 2;
}

struct ModuleImportRecord {
  ModuleImportType kind;
  string path;

  bool dynamic;
}

struct Module {
  string path;
  ModuleImportRecord[] imports;
}

struct StringMap {
  string[] keys;
  string[] values;
}

struct LoaderMap {
  string[] extensions;
  Loader[] loaders;
}

message TransformOptions {
  JSX jsx = 1;
  string tsconfig_override = 2;
  ResolveMode resolve = 3;

  string public_url = 4;
  string absolute_working_dir = 5;

  StringMap define = 6;

  bool preserve_symlinks = 7;

  string[] entry_points = 8;
  bool write = 9;

  string[] inject = 10;
  string output_dir = 11;

  string[] external = 12;

  LoaderMap loaders = 13;

  string[] main_fields = 14;
  Platform platform = 15;

  bool serve = 16;

  string[] extension_order = 17;

  string public_dir = 18;

  ScanDependencyMode only_scan_dependencies = 19;

  bool generate_node_module_bundle = 20;

  string node_modules_bundle_path = 21;
}

struct FileHandle {
  string path;
  uint size;
  uint fd; 
}

message Transform {
  FileHandle handle = 1;
  string path = 2;
  byte[] contents = 3;

  Loader loader = 4;
  TransformOptions options = 5;
}

enum TransformResponseStatus {
  success = 1;
  fail = 2;
}

struct OutputFile {
  byte[] data;
  string path;
}

struct TransformResponse {
  TransformResponseStatus status;
  OutputFile[] files;
  Message[] errors;
}

enum MessageKind {
  err = 1;
  warn  =2;
  note = 3;
  debug = 4;
}

struct Location {
  string file;
  string namespace;
  int32 line;
  int32 column;
  string line_text;
  string suggestion;
  uint offset;
}

message MessageData {
  string text = 1;
   Location location = 2;
}

struct Message {
  MessageKind kind;
  MessageData data;
  MessageData[] notes;
}

struct Log {
  uint32 warnings;
  uint32 errors;
  Message[] msgs;
}


// The WebSocket protocol
// Server: "hey, this file changed. Does anyone want it?"
// Client: *checks hash table* "uhh yeah, ok. rebuild that for me"
// Server: "here u go"
// This makes the client responsible for tracking which files it needs to listen for.
// From a server perspective, this means the filesystem watching thread can send the same WebSocket message
// to every client, which is good for performance. It means if you have 5 tabs open it won't really be different than one tab
// The clients can just ignore files they don't care about
smol WebsocketMessageKind {
  welcome = 1;
  file_change_notification = 2;
  build_success = 3;
  build_fail = 4;
}

smol WebsocketCommandKind {
  build = 1;
}

// Each websocket message has two messages in it!
// This is the first.
struct WebsocketMessage {
  uint32 timestamp;
  WebsocketMessageKind kind;
}

// This is the first.
struct WebsocketMessageWelcome {
  uint32 epoch;
}

struct WebsocketMessageFileChangeNotification {
  uint32 id;
  Loader loader;
}

struct WebsocketCommand {
  WebsocketCommandKind kind;
  uint32 timestamp;
}

// The timestamp is used for client-side deduping
struct WebsocketCommandBuild {
  uint32 id;
}

// We copy the module_path here incase they don't already have it
struct WebsocketMessageBuildSuccess {
  uint32 id;
  uint32 from_timestamp;

  Loader loader;
  alphanumeric module_path;
  
  Log log;
  byte[] bytes;
}

struct WebsocketMessageBuildFailure {
  uint32 id;
  uint32 from_timestamp;
  Loader loader;

  alphanumeric module_path;
  Log log;
}




